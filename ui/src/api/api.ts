/* tslint:disable */
/* eslint-disable */
/**
 * api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface AccountAssetEntryViewModel
 */
export interface AccountAssetEntryViewModel {
  /**
   * The id of an account for which to the entry is related.
   * @type {string}
   * @memberof AccountAssetEntryViewModel
   */
  account_id: string;
  /**
   * The number of units of the asset that were added or removed from the account.
   * @type {number}
   * @memberof AccountAssetEntryViewModel
   */
  amount: number;
  /**
   * The id of an asset in the account for which the entry is related.
   * @type {number}
   * @memberof AccountAssetEntryViewModel
   */
  asset_id: number;
}
/**
 *
 * @export
 * @interface AccountFeesViewModel
 */
export interface AccountFeesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AccountFeesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof AccountFeesViewModel
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AccountFeesViewModel
   */
  entry: AccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface AccountFeesViewModelWithType
 */
export interface AccountFeesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AccountFeesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof AccountFeesViewModelWithType
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AccountFeesViewModelWithType
   */
  entry: AccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof AccountFeesViewModelWithType
   */
  type: AccountFeesViewModelWithTypeTypeEnum;
}

export const AccountFeesViewModelWithTypeTypeEnum = {
  AccountFees: "account_fees",
} as const;

export type AccountFeesViewModelWithTypeTypeEnum =
  (typeof AccountFeesViewModelWithTypeTypeEnum)[keyof typeof AccountFeesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface AccountFeesWithIdentifiableEntriesViewModel
 */
export interface AccountFeesWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AccountFeesWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof AccountFeesWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AccountFeesWithIdentifiableEntriesViewModel
   */
  entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface AccountFeesWithIdentifiableEntriesViewModelWithType
 */
export interface AccountFeesWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AccountFeesWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof AccountFeesWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AccountFeesWithIdentifiableEntriesViewModelWithType
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof AccountFeesWithIdentifiableEntriesViewModelWithType
   */
  type: AccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const AccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum = {
  AccountFees: "account_fees",
} as const;

export type AccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof AccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof AccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface AccountMetadataLookupTables
 */
export interface AccountMetadataLookupTables {
  /**
   *
   * @type {Array<IdentifiableAccountLiquidityTypeViewModel>}
   * @memberof AccountMetadataLookupTables
   */
  account_liquidity_types: Array<IdentifiableAccountLiquidityTypeViewModel>;
  /**
   *
   * @type {Array<IdentifiableAccountTypeViewModel>}
   * @memberof AccountMetadataLookupTables
   */
  account_types: Array<IdentifiableAccountTypeViewModel>;
}
/**
 *
 * @export
 * @interface AccountTypeViewModel
 */
export interface AccountTypeViewModel {
  /**
   * The name of the Account type
   * @type {string}
   * @memberof AccountTypeViewModel
   */
  name: string;
}
/**
 *
 * @export
 * @interface AccountViewModel
 */
export interface AccountViewModel {
  /**
   *
   * @type {number}
   * @memberof AccountViewModel
   */
  account_type: number;
  /**
   *
   * @type {string}
   * @memberof AccountViewModel
   */
  name: string;
}
/**
 *
 * @export
 * @interface AddAccountRequestViewModel
 */
export interface AddAccountRequestViewModel {
  /**
   *
   * @type {number}
   * @memberof AddAccountRequestViewModel
   */
  account_type: number;
  /**
   *
   * @type {string}
   * @memberof AddAccountRequestViewModel
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof AddAccountRequestViewModel
   */
  liquidity_type: number;
}
/**
 *
 * @export
 * @interface AddAccountResponseViewModel
 */
export interface AddAccountResponseViewModel {
  /**
   *
   * @type {number}
   * @memberof AddAccountResponseViewModel
   */
  account_type: number;
  /**
   *
   * @type {string}
   * @memberof AddAccountResponseViewModel
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof AddAccountResponseViewModel
   */
  account_id: string;
  /**
   *
   * @type {number}
   * @memberof AddAccountResponseViewModel
   */
  liquidity_type: number;
}
/**
 *
 * @export
 * @interface AddAssetPairRatesRequestViewModel
 */
export interface AddAssetPairRatesRequestViewModel {
  /**
   *
   * @type {Array<AssetRateViewModel>}
   * @memberof AddAssetPairRatesRequestViewModel
   */
  rates: Array<AssetRateViewModel>;
}
/**
 *
 * @export
 * @interface AddAssetPairRatesResponseViewModel
 */
export interface AddAssetPairRatesResponseViewModel {
  /**
   *
   * @type {Array<AssetRateViewModel>}
   * @memberof AddAssetPairRatesResponseViewModel
   */
  rates: Array<AssetRateViewModel>;
}
/**
 *
 * @export
 * @interface AddAssetRequestViewModel
 */
export interface AddAssetRequestViewModel {
  /**
   *
   * @type {number}
   * @memberof AddAssetRequestViewModel
   */
  asset_type: number;
  /**
   *
   * @type {string}
   * @memberof AddAssetRequestViewModel
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof AddAssetRequestViewModel
   */
  ticker: string;
  /**
   *
   * @type {number}
   * @memberof AddAssetRequestViewModel
   */
  base_asset_id: number;
}
/**
 *
 * @export
 * @interface AddAssetResponseViewModel
 */
export interface AddAssetResponseViewModel {
  /**
   *
   * @type {number}
   * @memberof AddAssetResponseViewModel
   */
  asset_type: number;
  /**
   *
   * @type {string}
   * @memberof AddAssetResponseViewModel
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof AddAssetResponseViewModel
   */
  ticker: string;
  /**
   *
   * @type {number}
   * @memberof AddAssetResponseViewModel
   */
  asset_id: number;
  /**
   *
   * @type {number}
   * @memberof AddAssetResponseViewModel
   */
  base_asset_id: number;
}
/**
 *
 * @export
 * @interface AddIndividualTransactionRequestViewModel
 */
export interface AddIndividualTransactionRequestViewModel {
  /**
   *
   * @type {TransactionWithEntries}
   * @memberof AddIndividualTransactionRequestViewModel
   */
  transaction: TransactionWithEntries;
}
/**
 *
 * @export
 * @interface AddIndividualTransactionResponseViewModel
 */
export interface AddIndividualTransactionResponseViewModel {
  /**
   *
   * @type {MandatoryIdentifiableTransactionWithIdentifiableEntries}
   * @memberof AddIndividualTransactionResponseViewModel
   */
  transaction: MandatoryIdentifiableTransactionWithIdentifiableEntries;
}
/**
 *
 * @export
 * @interface AddTransactionGroupRequestViewModel
 */
export interface AddTransactionGroupRequestViewModel {
  /**
   * Overall category of whole group
   * @type {number}
   * @memberof AddTransactionGroupRequestViewModel
   */
  category_id: number;
  /**
   * Unrelated to individual transactions date which represent when the collection of transactions occurred
   * @type {string}
   * @memberof AddTransactionGroupRequestViewModel
   */
  date: number;
  /**
   * Overall description of whole group
   * @type {string}
   * @memberof AddTransactionGroupRequestViewModel
   */
  description: string;
  /**
   * All subtractions grouped into this group
   * @type {Array<TransactionWithEntries>}
   * @memberof AddTransactionGroupRequestViewModel
   */
  transactions: Array<TransactionWithEntries>;
}
/**
 *
 * @export
 * @interface AddTransactionGroupResponseViewModel
 */
export interface AddTransactionGroupResponseViewModel {
  /**
   *
   * @type {Array<IdentifiableAccountViewModel>}
   * @memberof AddTransactionGroupResponseViewModel
   */
  accounts: Array<IdentifiableAccountViewModel>;
  /**
   *
   * @type {Array<IdentifiableAssetViewModel>}
   * @memberof AddTransactionGroupResponseViewModel
   */
  assets: Array<IdentifiableAssetViewModel>;
  /**
   *
   * @type {MandatoryIdentifiableTransactionGroupViewModel}
   * @memberof AddTransactionGroupResponseViewModel
   */
  group: MandatoryIdentifiableTransactionGroupViewModel;
}
/**
 *
 * @export
 * @interface AssetBalanceTransferViewModel
 */
export interface AssetBalanceTransferViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetBalanceTransferViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof AssetBalanceTransferViewModel
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetBalanceTransferViewModel
   */
  incoming_change: AccountAssetEntryViewModel;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetBalanceTransferViewModel
   */
  outgoing_change: AccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface AssetBalanceTransferViewModelWithType
 */
export interface AssetBalanceTransferViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetBalanceTransferViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof AssetBalanceTransferViewModelWithType
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetBalanceTransferViewModelWithType
   */
  incoming_change: AccountAssetEntryViewModel;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetBalanceTransferViewModelWithType
   */
  outgoing_change: AccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof AssetBalanceTransferViewModelWithType
   */
  type: AssetBalanceTransferViewModelWithTypeTypeEnum;
}

export const AssetBalanceTransferViewModelWithTypeTypeEnum = {
  AssetBalanceTransfer: "asset_balance_transfer",
} as const;

export type AssetBalanceTransferViewModelWithTypeTypeEnum =
  (typeof AssetBalanceTransferViewModelWithTypeTypeEnum)[keyof typeof AssetBalanceTransferViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface AssetBalanceTransferWithIdentifiableEntriesViewModel
 */
export interface AssetBalanceTransferWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof AssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  incoming_change: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  outgoing_change: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface AssetBalanceTransferWithIdentifiableEntriesViewModelWithType
 */
export interface AssetBalanceTransferWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof AssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  incoming_change: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  outgoing_change: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof AssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  type: AssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const AssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetBalanceTransfer: "asset_balance_transfer",
  } as const;

export type AssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof AssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof AssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface AssetDividendViewModel
 */
export interface AssetDividendViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetDividendViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof AssetDividendViewModel
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetDividendViewModel
   */
  entry: AccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface AssetDividendViewModelWithType
 */
export interface AssetDividendViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetDividendViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof AssetDividendViewModelWithType
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetDividendViewModelWithType
   */
  entry: AccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof AssetDividendViewModelWithType
   */
  type: AssetDividendViewModelWithTypeTypeEnum;
}

export const AssetDividendViewModelWithTypeTypeEnum = {
  AssetDividend: "asset_dividend",
} as const;

export type AssetDividendViewModelWithTypeTypeEnum =
  (typeof AssetDividendViewModelWithTypeTypeEnum)[keyof typeof AssetDividendViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface AssetDividendWithIdentifiableEntriesViewModel
 */
export interface AssetDividendWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetDividendWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof AssetDividendWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetDividendWithIdentifiableEntriesViewModel
   */
  entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface AssetDividendWithIdentifiableEntriesViewModelWithType
 */
export interface AssetDividendWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetDividendWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof AssetDividendWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetDividendWithIdentifiableEntriesViewModelWithType
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof AssetDividendWithIdentifiableEntriesViewModelWithType
   */
  type: AssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const AssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum = {
  AssetDividend: "asset_dividend",
} as const;

export type AssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof AssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof AssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface AssetLookupTables
 */
export interface AssetLookupTables {
  /**
   *
   * @type {Array<IdentifiableAssetTypeViewModel>}
   * @memberof AssetLookupTables
   */
  asset_types: Array<IdentifiableAssetTypeViewModel>;
}
/**
 *
 * @export
 * @interface AssetMetadataViewModel
 */
export interface AssetMetadataViewModel {
  /**
   * Id of the asset paired to this asset by default.
   * @type {number}
   * @memberof AssetMetadataViewModel
   */
  base_asset_id: number;
  /**
   * Ids of available second assets paired to this asset.
   * @type {Array<number>}
   * @memberof AssetMetadataViewModel
   */
  pairs: Array<number>;
}
/**
 *
 * @export
 * @interface AssetPairMetadataViewModel
 */
export interface AssetPairMetadataViewModel {
  /**
   *
   * @type {string}
   * @memberof AssetPairMetadataViewModel
   */
  last_updated: string;
  /**
   *
   * @type {number}
   * @memberof AssetPairMetadataViewModel
   */
  latest_rate: number;
}
/**
 *
 * @export
 * @interface AssetPurchaseViewModel
 */
export interface AssetPurchaseViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetPurchaseViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof AssetPurchaseViewModel
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetPurchaseViewModel
   */
  cash_outgoings_change: AccountAssetEntryViewModel;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetPurchaseViewModel
   */
  purchase_change: AccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface AssetPurchaseViewModelWithType
 */
export interface AssetPurchaseViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetPurchaseViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof AssetPurchaseViewModelWithType
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetPurchaseViewModelWithType
   */
  cash_outgoings_change: AccountAssetEntryViewModel;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetPurchaseViewModelWithType
   */
  purchase_change: AccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof AssetPurchaseViewModelWithType
   */
  type: AssetPurchaseViewModelWithTypeTypeEnum;
}

export const AssetPurchaseViewModelWithTypeTypeEnum = {
  AssetPurchase: "asset_purchase",
} as const;

export type AssetPurchaseViewModelWithTypeTypeEnum =
  (typeof AssetPurchaseViewModelWithTypeTypeEnum)[keyof typeof AssetPurchaseViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface AssetPurchaseWithIdentifiableEntriesViewModel
 */
export interface AssetPurchaseWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetPurchaseWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof AssetPurchaseWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetPurchaseWithIdentifiableEntriesViewModel
   */
  cash_outgoings_change: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetPurchaseWithIdentifiableEntriesViewModel
   */
  purchase_change: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface AssetPurchaseWithIdentifiableEntriesViewModelWithType
 */
export interface AssetPurchaseWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof AssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  cash_outgoings_change: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  purchase_change: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof AssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  type: AssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const AssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum = {
  AssetPurchase: "asset_purchase",
} as const;

export type AssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof AssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof AssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface AssetRateViewModel
 */
export interface AssetRateViewModel {
  /**
   *
   * @type {string}
   * @memberof AssetRateViewModel
   */
  date: number;
  /**
   *
   * @type {number}
   * @memberof AssetRateViewModel
   */
  rate: number;
}
/**
 *
 * @export
 * @interface AssetSaleViewModel
 */
export interface AssetSaleViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetSaleViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof AssetSaleViewModel
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetSaleViewModel
   */
  proceeds_entry: AccountAssetEntryViewModel;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetSaleViewModel
   */
  sale_entry: AccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface AssetSaleViewModelWithType
 */
export interface AssetSaleViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetSaleViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof AssetSaleViewModelWithType
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetSaleViewModelWithType
   */
  proceeds_entry: AccountAssetEntryViewModel;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetSaleViewModelWithType
   */
  sale_entry: AccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof AssetSaleViewModelWithType
   */
  type: AssetSaleViewModelWithTypeTypeEnum;
}

export const AssetSaleViewModelWithTypeTypeEnum = {
  AssetSale: "asset_sale",
} as const;

export type AssetSaleViewModelWithTypeTypeEnum =
  (typeof AssetSaleViewModelWithTypeTypeEnum)[keyof typeof AssetSaleViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface AssetSaleWithIdentifiableEntriesViewModel
 */
export interface AssetSaleWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetSaleWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof AssetSaleWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetSaleWithIdentifiableEntriesViewModel
   */
  proceeds_entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetSaleWithIdentifiableEntriesViewModel
   */
  sale_entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface AssetSaleWithIdentifiableEntriesViewModelWithType
 */
export interface AssetSaleWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetSaleWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof AssetSaleWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetSaleWithIdentifiableEntriesViewModelWithType
   */
  proceeds_entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetSaleWithIdentifiableEntriesViewModelWithType
   */
  sale_entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof AssetSaleWithIdentifiableEntriesViewModelWithType
   */
  type: AssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const AssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum = {
  AssetSale: "asset_sale",
} as const;

export type AssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof AssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof AssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface AssetTradeViewModel
 */
export interface AssetTradeViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetTradeViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof AssetTradeViewModel
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetTradeViewModel
   */
  incoming_entry: AccountAssetEntryViewModel;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetTradeViewModel
   */
  outgoing_entry: AccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface AssetTradeViewModelWithType
 */
export interface AssetTradeViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetTradeViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof AssetTradeViewModelWithType
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetTradeViewModelWithType
   */
  incoming_entry: AccountAssetEntryViewModel;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetTradeViewModelWithType
   */
  outgoing_entry: AccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof AssetTradeViewModelWithType
   */
  type: AssetTradeViewModelWithTypeTypeEnum;
}

export const AssetTradeViewModelWithTypeTypeEnum = {
  AssetTrade: "asset_trade",
} as const;

export type AssetTradeViewModelWithTypeTypeEnum =
  (typeof AssetTradeViewModelWithTypeTypeEnum)[keyof typeof AssetTradeViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface AssetTradeWithIdentifiableEntriesViewModel
 */
export interface AssetTradeWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetTradeWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof AssetTradeWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetTradeWithIdentifiableEntriesViewModel
   */
  incoming_entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetTradeWithIdentifiableEntriesViewModel
   */
  outgoing_entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface AssetTradeWithIdentifiableEntriesViewModelWithType
 */
export interface AssetTradeWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetTradeWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof AssetTradeWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetTradeWithIdentifiableEntriesViewModelWithType
   */
  incoming_entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetTradeWithIdentifiableEntriesViewModelWithType
   */
  outgoing_entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof AssetTradeWithIdentifiableEntriesViewModelWithType
   */
  type: AssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const AssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum = {
  AssetTrade: "asset_trade",
} as const;

export type AssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof AssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof AssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface AssetTransferInViewModel
 */
export interface AssetTransferInViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetTransferInViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof AssetTransferInViewModel
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetTransferInViewModel
   */
  entry: AccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface AssetTransferInViewModelWithType
 */
export interface AssetTransferInViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetTransferInViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof AssetTransferInViewModelWithType
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetTransferInViewModelWithType
   */
  entry: AccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof AssetTransferInViewModelWithType
   */
  type: AssetTransferInViewModelWithTypeTypeEnum;
}

export const AssetTransferInViewModelWithTypeTypeEnum = {
  AssetTransferIn: "asset_transfer_in",
} as const;

export type AssetTransferInViewModelWithTypeTypeEnum =
  (typeof AssetTransferInViewModelWithTypeTypeEnum)[keyof typeof AssetTransferInViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface AssetTransferInWithIdentifiableEntriesViewModel
 */
export interface AssetTransferInWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetTransferInWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof AssetTransferInWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetTransferInWithIdentifiableEntriesViewModel
   */
  entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface AssetTransferInWithIdentifiableEntriesViewModelWithType
 */
export interface AssetTransferInWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof AssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof AssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  type: AssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const AssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum = {
  AssetTransferIn: "asset_transfer_in",
} as const;

export type AssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof AssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof AssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface AssetTransferOutViewModel
 */
export interface AssetTransferOutViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetTransferOutViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof AssetTransferOutViewModel
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetTransferOutViewModel
   */
  entry: AccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface AssetTransferOutViewModelWithType
 */
export interface AssetTransferOutViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetTransferOutViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof AssetTransferOutViewModelWithType
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof AssetTransferOutViewModelWithType
   */
  entry: AccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof AssetTransferOutViewModelWithType
   */
  type: AssetTransferOutViewModelWithTypeTypeEnum;
}

export const AssetTransferOutViewModelWithTypeTypeEnum = {
  AssetTransferOut: "asset_transfer_out",
} as const;

export type AssetTransferOutViewModelWithTypeTypeEnum =
  (typeof AssetTransferOutViewModelWithTypeTypeEnum)[keyof typeof AssetTransferOutViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface AssetTransferOutWithIdentifiableEntriesViewModel
 */
export interface AssetTransferOutWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetTransferOutWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof AssetTransferOutWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetTransferOutWithIdentifiableEntriesViewModel
   */
  entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface AssetTransferOutWithIdentifiableEntriesViewModelWithType
 */
export interface AssetTransferOutWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof AssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof AssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof AssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof AssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  type: AssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const AssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetTransferOut: "asset_transfer_out",
  } as const;

export type AssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof AssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof AssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface AssetViewModel
 */
export interface AssetViewModel {
  /**
   *
   * @type {number}
   * @memberof AssetViewModel
   */
  asset_type: number;
  /**
   *
   * @type {string}
   * @memberof AssetViewModel
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof AssetViewModel
   */
  ticker: string;
}

export interface AuthViewModel {
  token: string;
}
/**
 *
 * @export
 * @interface CashDividendViewModel
 */
export interface CashDividendViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof CashDividendViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof CashDividendViewModel
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof CashDividendViewModel
   */
  entry: AccountAssetEntryViewModel;
  /**
   * An id of a cash asset for which the dividends were paid for.
   * @type {number}
   * @memberof CashDividendViewModel
   */
  origin_asset_id: number;
}
/**
 *
 * @export
 * @interface CashDividendViewModelWithType
 */
export interface CashDividendViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof CashDividendViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof CashDividendViewModelWithType
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof CashDividendViewModelWithType
   */
  entry: AccountAssetEntryViewModel;
  /**
   * An id of a cash asset for which the dividends were paid for.
   * @type {number}
   * @memberof CashDividendViewModelWithType
   */
  origin_asset_id: number;
  /**
   *
   * @type {string}
   * @memberof CashDividendViewModelWithType
   */
  type: CashDividendViewModelWithTypeTypeEnum;
}

export const CashDividendViewModelWithTypeTypeEnum = {
  CashDividend: "cash_dividend",
} as const;

export type CashDividendViewModelWithTypeTypeEnum =
  (typeof CashDividendViewModelWithTypeTypeEnum)[keyof typeof CashDividendViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface CashDividendWithIdentifiableEntriesViewModel
 */
export interface CashDividendWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof CashDividendWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof CashDividendWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof CashDividendWithIdentifiableEntriesViewModel
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   * An id of a cash asset for which the dividends were paid for.
   * @type {number}
   * @memberof CashDividendWithIdentifiableEntriesViewModel
   */
  origin_asset_id: number;
}
/**
 *
 * @export
 * @interface CashDividendWithIdentifiableEntriesViewModelWithType
 */
export interface CashDividendWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof CashDividendWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof CashDividendWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof CashDividendWithIdentifiableEntriesViewModelWithType
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   * An id of a cash asset for which the dividends were paid for.
   * @type {number}
   * @memberof CashDividendWithIdentifiableEntriesViewModelWithType
   */
  origin_asset_id: number;
  /**
   *
   * @type {string}
   * @memberof CashDividendWithIdentifiableEntriesViewModelWithType
   */
  type: CashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const CashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum = {
  CashDividend: "cash_dividend",
} as const;

export type CashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof CashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof CashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface CashTransferInViewModel
 */
export interface CashTransferInViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof CashTransferInViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof CashTransferInViewModel
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof CashTransferInViewModel
   */
  entry: AccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface CashTransferInViewModelWithType
 */
export interface CashTransferInViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof CashTransferInViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof CashTransferInViewModelWithType
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof CashTransferInViewModelWithType
   */
  entry: AccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof CashTransferInViewModelWithType
   */
  type: CashTransferInViewModelWithTypeTypeEnum;
}

export const CashTransferInViewModelWithTypeTypeEnum = {
  CashTransferIn: "cash_transfer_in",
} as const;

export type CashTransferInViewModelWithTypeTypeEnum =
  (typeof CashTransferInViewModelWithTypeTypeEnum)[keyof typeof CashTransferInViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface CashTransferInWithIdentifiableEntriesViewModel
 */
export interface CashTransferInWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof CashTransferInWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof CashTransferInWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof CashTransferInWithIdentifiableEntriesViewModel
   */
  entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface CashTransferInWithIdentifiableEntriesViewModelWithType
 */
export interface CashTransferInWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof CashTransferInWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof CashTransferInWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof CashTransferInWithIdentifiableEntriesViewModelWithType
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof CashTransferInWithIdentifiableEntriesViewModelWithType
   */
  type: CashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const CashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum = {
  CashTransferIn: "cash_transfer_in",
} as const;

export type CashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof CashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof CashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface CashTransferOutViewModel
 */
export interface CashTransferOutViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof CashTransferOutViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof CashTransferOutViewModel
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof CashTransferOutViewModel
   */
  entry: AccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface CashTransferOutViewModelWithType
 */
export interface CashTransferOutViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof CashTransferOutViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof CashTransferOutViewModelWithType
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof CashTransferOutViewModelWithType
   */
  entry: AccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof CashTransferOutViewModelWithType
   */
  type: CashTransferOutViewModelWithTypeTypeEnum;
}

export const CashTransferOutViewModelWithTypeTypeEnum = {
  CashTransferOut: "cash_transfer_out",
} as const;

export type CashTransferOutViewModelWithTypeTypeEnum =
  (typeof CashTransferOutViewModelWithTypeTypeEnum)[keyof typeof CashTransferOutViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface CashTransferOutWithIdentifiableEntriesViewModel
 */
export interface CashTransferOutWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof CashTransferOutWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof CashTransferOutWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof CashTransferOutWithIdentifiableEntriesViewModel
   */
  entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface CashTransferOutWithIdentifiableEntriesViewModelWithType
 */
export interface CashTransferOutWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof CashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof CashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof CashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof CashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  type: CashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const CashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum = {
  CashTransferOut: "cash_transfer_out",
} as const;

export type CashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof CashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof CashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface ExpandedAccountViewModel
 */
export interface ExpandedAccountViewModel {
  /**
   *
   * @type {IdentifiableAccountTypeViewModel}
   * @memberof ExpandedAccountViewModel
   */
  account_type: IdentifiableAccountTypeViewModel;
  /**
   *
   * @type {string}
   * @memberof ExpandedAccountViewModel
   */
  name: string;
}
/**
 *
 * @export
 * @interface ExpandedAssetViewModel
 */
export interface ExpandedAssetViewModel {
  /**
   *
   * @type {IdentifiableAssetTypeViewModel}
   * @memberof ExpandedAssetViewModel
   */
  asset_type: IdentifiableAssetTypeViewModel;
  /**
   *
   * @type {string}
   * @memberof ExpandedAssetViewModel
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ExpandedAssetViewModel
   */
  ticker: string;
}
/**
 *
 * @export
 * @interface GetAccountLiquidityTypesResponseViewModel
 */
export interface GetAccountLiquidityTypesResponseViewModel {
  /**
   *
   * @type {Array<IdentifiableAccountLiquidityTypeViewModel>}
   * @memberof GetAccountLiquidityTypesResponseViewModel
   */
  account_liquidity_types: Array<IdentifiableAccountLiquidityTypeViewModel>;
}
/**
 *
 * @export
 * @interface GetAccountResponseViewModel
 */
export interface GetAccountResponseViewModel {
  /**
   *
   * @type {IdentifiableAccountTypeViewModel}
   * @memberof GetAccountResponseViewModel
   */
  account_type: IdentifiableAccountTypeViewModel;
  /**
   *
   * @type {string}
   * @memberof GetAccountResponseViewModel
   */
  name: string;
  /**
   *
   * @type {IdentifiableAccountLiquidityTypeViewModel}
   * @memberof GetAccountResponseViewModel
   */
  liquidity_type: IdentifiableAccountLiquidityTypeViewModel;
}
/**
 *
 * @export
 * @interface GetAccountTypesResponseViewModel
 */
export interface GetAccountTypesResponseViewModel {
  /**
   *
   * @type {Array<IdentifiableAccountTypeViewModel>}
   * @memberof GetAccountTypesResponseViewModel
   */
  account_types: Array<IdentifiableAccountTypeViewModel>;
}
/**
 *
 * @export
 * @interface GetAccountsResponseViewModel
 */
export interface GetAccountsResponseViewModel {
  /**
   *
   * @type {Array<GetAccountsResponseViewModelRow>}
   * @memberof GetAccountsResponseViewModel
   */
  accounts: Array<GetAccountsResponseViewModelRow>;
  /**
   *
   * @type {AccountMetadataLookupTables}
   * @memberof GetAccountsResponseViewModel
   */
  lookup_tables: AccountMetadataLookupTables;
}
/**
 *
 * @export
 * @interface GetAccountsResponseViewModelRow
 */
export interface GetAccountsResponseViewModelRow {
  /**
   *
   * @type {number}
   * @memberof GetAccountsResponseViewModelRow
   */
  account_type: number;
  /**
   *
   * @type {string}
   * @memberof GetAccountsResponseViewModelRow
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof GetAccountsResponseViewModelRow
   */
  account_id: string;
  /**
   *
   * @type {number}
   * @memberof GetAccountsResponseViewModelRow
   */
  liquidity_type: number;
}
/**
 *
 * @export
 * @interface GetAssetPairRatesResponseViewModel
 */
export interface GetAssetPairRatesResponseViewModel {
  /**
   *
   * @type {string}
   * @memberof GetAssetPairRatesResponseViewModel
   */
  range: string;
  /**
   *
   * @type {Array<AssetRateViewModel>}
   * @memberof GetAssetPairRatesResponseViewModel
   */
  rates: Array<AssetRateViewModel>;
}
/**
 *
 * @export
 * @interface GetAssetPairResponseViewModel
 */
export interface GetAssetPairResponseViewModel {
  /**
   *
   * @type {ExpandedAssetViewModel}
   * @memberof GetAssetPairResponseViewModel
   */
  main_asset: ExpandedAssetViewModel;
  /**
   *
   * @type {SharedAssetPairMetadataViewModel}
   * @memberof GetAssetPairResponseViewModel
   */
  metadata: SharedAssetPairMetadataViewModel;
  /**
   *
   * @type {ExpandedAssetViewModel}
   * @memberof GetAssetPairResponseViewModel
   */
  reference_asset: ExpandedAssetViewModel;
}
/**
 *
 * @export
 * @interface GetAssetResponseViewModel
 */
export interface GetAssetResponseViewModel {
  /**
   *
   * @type {IdentifiableAssetTypeViewModel}
   * @memberof GetAssetResponseViewModel
   */
  asset_type: IdentifiableAssetTypeViewModel;
  /**
   *
   * @type {string}
   * @memberof GetAssetResponseViewModel
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof GetAssetResponseViewModel
   */
  ticker: string;
  /**
   * Id of the asset paired to this asset by default.
   * @type {number}
   * @memberof GetAssetResponseViewModel
   */
  base_asset_id: number;
  /**
   * Ids of available second assets paired to this asset.
   * @type {Array<number>}
   * @memberof GetAssetResponseViewModel
   */
  pairs: Array<number>;
}
/**
 *
 * @export
 * @interface GetAssetsLineResponseViewModel
 */
export interface GetAssetsLineResponseViewModel {
  /**
   *
   * @type {number}
   * @memberof GetAssetsLineResponseViewModel
   */
  asset_type: number;
  /**
   *
   * @type {string}
   * @memberof GetAssetsLineResponseViewModel
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof GetAssetsLineResponseViewModel
   */
  ticker: string;
  /**
   *
   * @type {number}
   * @memberof GetAssetsLineResponseViewModel
   */
  asset_id: number;
}
/**
 *
 * @export
 * @interface GetHoldingsResponseViewModel
 */
export interface GetHoldingsResponseViewModel {
  /**
   *
   * @type {Array<GetHoldingsResponseViewModelRow>}
   * @memberof GetHoldingsResponseViewModel
   */
  holdings: Array<GetHoldingsResponseViewModelRow>;
  /**
   *
   * @type {HoldingsMetadataLookupTables}
   * @memberof GetHoldingsResponseViewModel
   */
  lookup_tables: HoldingsMetadataLookupTables;
}
/**
 *
 * @export
 * @interface GetHoldingsResponseViewModelRow
 */
export interface GetHoldingsResponseViewModelRow {
  /**
   *
   * @type {string}
   * @memberof GetHoldingsResponseViewModelRow
   */
  account_id: string;
  /**
   *
   * @type {number}
   * @memberof GetHoldingsResponseViewModelRow
   */
  asset_id: number;
  /**
   *
   * @type {number}
   * @memberof GetHoldingsResponseViewModelRow
   */
  units: number;
  /**
   *
   * @type {number}
   * @memberof GetHoldingsResponseViewModelRow
   */
  value?: number | null;
}
/**
 *
 * @export
 * @interface GetIndividualTransactionViewModel
 */
export interface GetIndividualTransactionViewModel {
  /**
   *
   * @type {MetadataLookupTables}
   * @memberof GetIndividualTransactionViewModel
   */
  lookup_tables: MetadataLookupTables;
  /**
   *
   * @type {MandatoryTransactionWithIdentifiableEntries}
   * @memberof GetIndividualTransactionViewModel
   */
  transaction: MandatoryTransactionWithIdentifiableEntries;
}
/**
 *
 * @export
 * @interface GetIndividualTransactionsViewModel
 */
export interface GetIndividualTransactionsViewModel {
  /**
   *
   * @type {Array<IdentifiableAccountViewModel>}
   * @memberof GetIndividualTransactionsViewModel
   */
  accounts: Array<IdentifiableAccountViewModel>;
  /**
   *
   * @type {Array<IdentifiableAssetViewModel>}
   * @memberof GetIndividualTransactionsViewModel
   */
  assets: Array<IdentifiableAssetViewModel>;
  /**
   *
   * @type {Array<MandatoryIdentifiableTransactionWithIdentifiableEntries>}
   * @memberof GetIndividualTransactionsViewModel
   */
  transactions: Array<MandatoryIdentifiableTransactionWithIdentifiableEntries>;
}
/**
 *
 * @export
 * @interface GetNetWorthHistoryResponseViewModel
 */
export interface GetNetWorthHistoryResponseViewModel {
  /**
   *
   * @type {string}
   * @memberof GetNetWorthHistoryResponseViewModel
   */
  range: string;
  /**
   *
   * @type {Array<AssetRateViewModel>}
   * @memberof GetNetWorthHistoryResponseViewModel
   */
  sums: Array<AssetRateViewModel>;
}
/**
 *
 * @export
 * @interface GetTransactionGroupsViewModel
 */
export interface GetTransactionGroupsViewModel {
  /**
   *
   * @type {Array<IdentifiableAccountViewModel>}
   * @memberof GetTransactionGroupsViewModel
   */
  accounts: Array<IdentifiableAccountViewModel>;
  /**
   *
   * @type {Array<IdentifiableAssetViewModel>}
   * @memberof GetTransactionGroupsViewModel
   */
  assets: Array<IdentifiableAssetViewModel>;
  /**
   *
   * @type {Array<MandatoryIdentifiableTransactionGroupViewModel>}
   * @memberof GetTransactionGroupsViewModel
   */
  groups: Array<MandatoryIdentifiableTransactionGroupViewModel>;
}
/**
 *
 * @export
 * @interface GetTransactionsViewModel
 */
export interface GetTransactionsViewModel {
  /**
   *
   * @type {Array<IdentifiableAccountViewModel>}
   * @memberof GetTransactionsViewModel
   */
  accounts: Array<IdentifiableAccountViewModel>;
  /**
   *
   * @type {Array<IdentifiableAssetViewModel>}
   * @memberof GetTransactionsViewModel
   */
  assets: Array<IdentifiableAssetViewModel>;
  /**
   *
   * @type {Array<MandatoryIdentifiableTransactionWithIdentifiableEntries>}
   * @memberof GetTransactionsViewModel
   */
  individual_transactions: Array<MandatoryIdentifiableTransactionWithIdentifiableEntries>;
  /**
   *
   * @type {Array<MandatoryIdentifiableTransactionGroupViewModel>}
   * @memberof GetTransactionsViewModel
   */
  transaction_groups: Array<MandatoryIdentifiableTransactionGroupViewModel>;
}
/**
 *
 * @export
 * @interface GetUserAssetPairResponseViewModel
 */
export interface GetUserAssetPairResponseViewModel {
  /**
   *
   * @type {ExpandedAssetViewModel}
   * @memberof GetUserAssetPairResponseViewModel
   */
  main_asset: ExpandedAssetViewModel;
  /**
   *
   * @type {AssetPairMetadataViewModel}
   * @memberof GetUserAssetPairResponseViewModel
   */
  metadata: AssetPairMetadataViewModel;
  /**
   *
   * @type {ExpandedAssetViewModel}
   * @memberof GetUserAssetPairResponseViewModel
   */
  reference_asset: ExpandedAssetViewModel;
  /**
   *
   * @type {UserAssetPairMetadataViewModel}
   * @memberof GetUserAssetPairResponseViewModel
   */
  user_metadata: UserAssetPairMetadataViewModel;
}
/**
 *
 * @export
 * @interface HoldingsMetadataLookupTables
 */
export interface HoldingsMetadataLookupTables {
  /**
   *
   * @type {Array<IdentifiableAccountViewModel>}
   * @memberof HoldingsMetadataLookupTables
   */
  accounts: Array<IdentifiableAccountViewModel>;
  /**
   *
   * @type {Array<IdentifiableAssetViewModel>}
   * @memberof HoldingsMetadataLookupTables
   */
  assets: Array<IdentifiableAssetViewModel>;
}
/**
 *
 * @export
 * @interface IdentifiableAccountAssetEntryViewModel
 */
export interface IdentifiableAccountAssetEntryViewModel {
  /**
   * The id of an account for which to the entry is related.
   * @type {string}
   * @memberof IdentifiableAccountAssetEntryViewModel
   */
  account_id: string;
  /**
   * The number of units of the asset that were added or removed from the account.
   * @type {number}
   * @memberof IdentifiableAccountAssetEntryViewModel
   */
  amount: number;
  /**
   * The id of an asset in the account for which the entry is related.
   * @type {number}
   * @memberof IdentifiableAccountAssetEntryViewModel
   */
  asset_id: number;
  /**
   * Id representing a single entry in a transaction.
   * @type {number}
   * @memberof IdentifiableAccountAssetEntryViewModel
   */
  entry_id?: number | null;
}
/**
 *
 * @export
 * @interface IdentifiableAccountFeesWithIdentifiableEntriesViewModel
 */
export interface IdentifiableAccountFeesWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableAccountFeesWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableAccountFeesWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableAccountFeesWithIdentifiableEntriesViewModel
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAccountFeesWithIdentifiableEntriesViewModel
   */
  entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface IdentifiableAccountFeesWithIdentifiableEntriesViewModelWithType
 */
export interface IdentifiableAccountFeesWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableAccountFeesWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableAccountFeesWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableAccountFeesWithIdentifiableEntriesViewModelWithType
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAccountFeesWithIdentifiableEntriesViewModelWithType
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof IdentifiableAccountFeesWithIdentifiableEntriesViewModelWithType
   */
  type: IdentifiableAccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const IdentifiableAccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AccountFees: "account_fees",
  } as const;

export type IdentifiableAccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof IdentifiableAccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof IdentifiableAccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface IdentifiableAccountLiquidityTypeViewModel
 */
export interface IdentifiableAccountLiquidityTypeViewModel {
  /**
   * The id of the Account type
   * @type {number}
   * @memberof IdentifiableAccountLiquidityTypeViewModel
   */
  id: number;
  /**
   * The name of the Account type
   * @type {string}
   * @memberof IdentifiableAccountLiquidityTypeViewModel
   */
  name: string;
}
/**
 *
 * @export
 * @interface IdentifiableAccountTypeViewModel
 */
export interface IdentifiableAccountTypeViewModel {
  /**
   * The id of the Account type
   * @type {number}
   * @memberof IdentifiableAccountTypeViewModel
   */
  id: number;
  /**
   * The name of the Account type
   * @type {string}
   * @memberof IdentifiableAccountTypeViewModel
   */
  name: string;
}
/**
 *
 * @export
 * @interface IdentifiableAccountViewModel
 */
export interface IdentifiableAccountViewModel {
  /**
   *
   * @type {number}
   * @memberof IdentifiableAccountViewModel
   */
  account_type: number;
  /**
   *
   * @type {string}
   * @memberof IdentifiableAccountViewModel
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof IdentifiableAccountViewModel
   */
  account_id: string;
}
/**
 *
 * @export
 * @interface IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModel
 */
export interface IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  incoming_change: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  outgoing_change: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
 */
export interface IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  incoming_change: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  outgoing_change: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  type: IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetBalanceTransfer: "asset_balance_transfer",
  } as const;

export type IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface IdentifiableAssetDividendWithIdentifiableEntriesViewModel
 */
export interface IdentifiableAssetDividendWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableAssetDividendWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableAssetDividendWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableAssetDividendWithIdentifiableEntriesViewModel
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetDividendWithIdentifiableEntriesViewModel
   */
  entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface IdentifiableAssetDividendWithIdentifiableEntriesViewModelWithType
 */
export interface IdentifiableAssetDividendWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableAssetDividendWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableAssetDividendWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableAssetDividendWithIdentifiableEntriesViewModelWithType
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetDividendWithIdentifiableEntriesViewModelWithType
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof IdentifiableAssetDividendWithIdentifiableEntriesViewModelWithType
   */
  type: IdentifiableAssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const IdentifiableAssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetDividend: "asset_dividend",
  } as const;

export type IdentifiableAssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof IdentifiableAssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof IdentifiableAssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface IdentifiableAssetPurchaseWithIdentifiableEntriesViewModel
 */
export interface IdentifiableAssetPurchaseWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableAssetPurchaseWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableAssetPurchaseWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableAssetPurchaseWithIdentifiableEntriesViewModel
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetPurchaseWithIdentifiableEntriesViewModel
   */
  cash_outgoings_change: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetPurchaseWithIdentifiableEntriesViewModel
   */
  purchase_change: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface IdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType
 */
export interface IdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  cash_outgoings_change: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  purchase_change: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof IdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  type: IdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const IdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetPurchase: "asset_purchase",
  } as const;

export type IdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof IdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof IdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface IdentifiableAssetSaleWithIdentifiableEntriesViewModel
 */
export interface IdentifiableAssetSaleWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableAssetSaleWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableAssetSaleWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableAssetSaleWithIdentifiableEntriesViewModel
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetSaleWithIdentifiableEntriesViewModel
   */
  proceeds_entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetSaleWithIdentifiableEntriesViewModel
   */
  sale_entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface IdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType
 */
export interface IdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  proceeds_entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  sale_entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof IdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  type: IdentifiableAssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const IdentifiableAssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetSale: "asset_sale",
  } as const;

export type IdentifiableAssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof IdentifiableAssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof IdentifiableAssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface IdentifiableAssetTradeWithIdentifiableEntriesViewModel
 */
export interface IdentifiableAssetTradeWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableAssetTradeWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableAssetTradeWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableAssetTradeWithIdentifiableEntriesViewModel
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetTradeWithIdentifiableEntriesViewModel
   */
  incoming_entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetTradeWithIdentifiableEntriesViewModel
   */
  outgoing_entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface IdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType
 */
export interface IdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  incoming_entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  outgoing_entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof IdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  type: IdentifiableAssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const IdentifiableAssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetTrade: "asset_trade",
  } as const;

export type IdentifiableAssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof IdentifiableAssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof IdentifiableAssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface IdentifiableAssetTransferInWithIdentifiableEntriesViewModel
 */
export interface IdentifiableAssetTransferInWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableAssetTransferInWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableAssetTransferInWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableAssetTransferInWithIdentifiableEntriesViewModel
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetTransferInWithIdentifiableEntriesViewModel
   */
  entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface IdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithType
 */
export interface IdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof IdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  type: IdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const IdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetTransferIn: "asset_transfer_in",
  } as const;

export type IdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof IdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof IdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface IdentifiableAssetTransferOutWithIdentifiableEntriesViewModel
 */
export interface IdentifiableAssetTransferOutWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableAssetTransferOutWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableAssetTransferOutWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableAssetTransferOutWithIdentifiableEntriesViewModel
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetTransferOutWithIdentifiableEntriesViewModel
   */
  entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface IdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithType
 */
export interface IdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof IdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  type: IdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const IdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetTransferOut: "asset_transfer_out",
  } as const;

export type IdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof IdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof IdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface IdentifiableAssetTypeViewModel
 */
export interface IdentifiableAssetTypeViewModel {
  /**
   * The id of the asset type
   * @type {number}
   * @memberof IdentifiableAssetTypeViewModel
   */
  id: number;
  /**
   * The name of the asset type
   * @type {string}
   * @memberof IdentifiableAssetTypeViewModel
   */
  name: string;
}
/**
 *
 * @export
 * @interface IdentifiableAssetViewModel
 */
export interface IdentifiableAssetViewModel {
  /**
   *
   * @type {number}
   * @memberof IdentifiableAssetViewModel
   */
  asset_type: number;
  /**
   *
   * @type {string}
   * @memberof IdentifiableAssetViewModel
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof IdentifiableAssetViewModel
   */
  ticker: string;
  /**
   *
   * @type {number}
   * @memberof IdentifiableAssetViewModel
   */
  asset_id: number;
}
/**
 *
 * @export
 * @interface IdentifiableCashDividendWithIdentifiableEntriesViewModel
 */
export interface IdentifiableCashDividendWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableCashDividendWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableCashDividendWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableCashDividendWithIdentifiableEntriesViewModel
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableCashDividendWithIdentifiableEntriesViewModel
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   * An id of a cash asset for which the dividends were paid for.
   * @type {number}
   * @memberof IdentifiableCashDividendWithIdentifiableEntriesViewModel
   */
  origin_asset_id: number;
}
/**
 *
 * @export
 * @interface IdentifiableCashDividendWithIdentifiableEntriesViewModelWithType
 */
export interface IdentifiableCashDividendWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableCashDividendWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableCashDividendWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableCashDividendWithIdentifiableEntriesViewModelWithType
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableCashDividendWithIdentifiableEntriesViewModelWithType
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   * An id of a cash asset for which the dividends were paid for.
   * @type {number}
   * @memberof IdentifiableCashDividendWithIdentifiableEntriesViewModelWithType
   */
  origin_asset_id: number;
  /**
   *
   * @type {string}
   * @memberof IdentifiableCashDividendWithIdentifiableEntriesViewModelWithType
   */
  type: IdentifiableCashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const IdentifiableCashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    CashDividend: "cash_dividend",
  } as const;

export type IdentifiableCashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof IdentifiableCashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof IdentifiableCashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface IdentifiableCashTransferInWithIdentifiableEntriesViewModel
 */
export interface IdentifiableCashTransferInWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableCashTransferInWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableCashTransferInWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableCashTransferInWithIdentifiableEntriesViewModel
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableCashTransferInWithIdentifiableEntriesViewModel
   */
  entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface IdentifiableCashTransferInWithIdentifiableEntriesViewModelWithType
 */
export interface IdentifiableCashTransferInWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableCashTransferInWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableCashTransferInWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableCashTransferInWithIdentifiableEntriesViewModelWithType
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableCashTransferInWithIdentifiableEntriesViewModelWithType
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof IdentifiableCashTransferInWithIdentifiableEntriesViewModelWithType
   */
  type: IdentifiableCashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const IdentifiableCashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    CashTransferIn: "cash_transfer_in",
  } as const;

export type IdentifiableCashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof IdentifiableCashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof IdentifiableCashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface IdentifiableCashTransferOutWithIdentifiableEntriesViewModel
 */
export interface IdentifiableCashTransferOutWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableCashTransferOutWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableCashTransferOutWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableCashTransferOutWithIdentifiableEntriesViewModel
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableCashTransferOutWithIdentifiableEntriesViewModel
   */
  entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface IdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithType
 */
export interface IdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  transaction_id?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof IdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  type: IdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const IdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    CashTransferOut: "cash_transfer_out",
  } as const;

export type IdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof IdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof IdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface IdentifiableExpandedAccountViewModel
 */
export interface IdentifiableExpandedAccountViewModel {
  /**
   *
   * @type {IdentifiableAccountTypeViewModel}
   * @memberof IdentifiableExpandedAccountViewModel
   */
  account_type: IdentifiableAccountTypeViewModel;
  /**
   *
   * @type {string}
   * @memberof IdentifiableExpandedAccountViewModel
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof IdentifiableExpandedAccountViewModel
   */
  account_id: string;
}
/**
 *
 * @export
 * @interface IdentifiableExpandedAssetViewModel
 */
export interface IdentifiableExpandedAssetViewModel {
  /**
   *
   * @type {IdentifiableAssetTypeViewModel}
   * @memberof IdentifiableExpandedAssetViewModel
   */
  asset_type: IdentifiableAssetTypeViewModel;
  /**
   *
   * @type {string}
   * @memberof IdentifiableExpandedAssetViewModel
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof IdentifiableExpandedAssetViewModel
   */
  ticker: string;
  /**
   *
   * @type {number}
   * @memberof IdentifiableExpandedAssetViewModel
   */
  asset_id: number;
}
/**
 *
 * @export
 * @interface IdentifiableRegularTransactionWithIdentifiableEntriesViewModel
 */
export interface IdentifiableRegularTransactionWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableRegularTransactionWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableRegularTransactionWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableRegularTransactionWithIdentifiableEntriesViewModel
   */
  transaction_id?: string | null;
  /**
   * Specific bespoke category id.
   * @type {number}
   * @memberof IdentifiableRegularTransactionWithIdentifiableEntriesViewModel
   */
  category_id: number;
  /**
   * Description of the transaction.
   * @type {string}
   * @memberof IdentifiableRegularTransactionWithIdentifiableEntriesViewModel
   */
  description?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableRegularTransactionWithIdentifiableEntriesViewModel
   */
  entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface IdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType
 */
export interface IdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  transaction_id?: string | null;
  /**
   * Specific bespoke category id.
   * @type {number}
   * @memberof IdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  category_id: number;
  /**
   * Description of the transaction.
   * @type {string}
   * @memberof IdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  description?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof IdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof IdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  type: IdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const IdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    RegularTransaction: "regular_transaction",
  } as const;

export type IdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof IdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof IdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface IdentifiableTransactionBaseWithIdentifiableEntries
 */
export interface IdentifiableTransactionBaseWithIdentifiableEntries {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof IdentifiableTransactionBaseWithIdentifiableEntries
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof IdentifiableTransactionBaseWithIdentifiableEntries
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof IdentifiableTransactionBaseWithIdentifiableEntries
   */
  transaction_id?: string | null;
}
/**
 *
 * @export
 * @interface IdentifiableTransactionFeeViewModel
 */
export interface IdentifiableTransactionFeeViewModel {
  /**
   * The id of an account for which to the entry is related.
   * @type {string}
   * @memberof IdentifiableTransactionFeeViewModel
   */
  account_id: string;
  /**
   * The number of units of the asset that were added or removed from the account.
   * @type {number}
   * @memberof IdentifiableTransactionFeeViewModel
   */
  amount: number;
  /**
   * The id of an asset in the account for which the entry is related.
   * @type {number}
   * @memberof IdentifiableTransactionFeeViewModel
   */
  asset_id: number;
  /**
   * Id representing a single entry in a transaction.
   * @type {number}
   * @memberof IdentifiableTransactionFeeViewModel
   */
  entry_id?: number | null;
  /**
   *
   * @type {TransactionFeeType}
   * @memberof IdentifiableTransactionFeeViewModel
   */
  fee_type: TransactionFeeType;
}

/**
 * @type IdentifiableTransactionWithIdentifiableEntries
 * @export
 */
export type IdentifiableTransactionWithIdentifiableEntries =
  | ({
      type: "account_fees";
    } & IdentifiableAccountFeesWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_balance_transfer";
    } & IdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_dividend";
    } & IdentifiableAssetDividendWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_purchase";
    } & IdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_sale";
    } & IdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_trade";
    } & IdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_transfer_in";
    } & IdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_transfer_out";
    } & IdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "cash_dividend";
    } & IdentifiableCashDividendWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "cash_transfer_in";
    } & IdentifiableCashTransferInWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "cash_transfer_out";
    } & IdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "regular_transaction";
    } & IdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType);

/**
 *
 * @export
 * @interface LoginDetailsViewModel
 */
export interface LoginDetailsViewModel {
  /**
   * Password.
   * @type {string}
   * @memberof LoginDetailsViewModel
   */
  password: string;
  /**
   * Username.
   * @type {string}
   * @memberof LoginDetailsViewModel
   */
  username: string;
}
/**
 *
 * @export
 * @interface MandatoryAccountFeesWithIdentifiableEntriesViewModel
 */
export interface MandatoryAccountFeesWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryAccountFeesWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryAccountFeesWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAccountFeesWithIdentifiableEntriesViewModel
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryAccountFeesWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryAccountFeesWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryAccountFeesWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryAccountFeesWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAccountFeesWithIdentifiableEntriesViewModelWithType
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryAccountFeesWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryAccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryAccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AccountFees: "account_fees",
  } as const;

export type MandatoryAccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryAccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryAccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModel
 */
export interface MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  incoming_change: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  outgoing_change: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  incoming_change: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  outgoing_change: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetBalanceTransfer: "asset_balance_transfer",
  } as const;

export type MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryAssetDividendWithIdentifiableEntriesViewModel
 */
export interface MandatoryAssetDividendWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryAssetDividendWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryAssetDividendWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetDividendWithIdentifiableEntriesViewModel
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryAssetDividendWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryAssetDividendWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryAssetDividendWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryAssetDividendWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetDividendWithIdentifiableEntriesViewModelWithType
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryAssetDividendWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryAssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryAssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetDividend: "asset_dividend",
  } as const;

export type MandatoryAssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryAssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryAssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryAssetPurchaseWithIdentifiableEntriesViewModel
 */
export interface MandatoryAssetPurchaseWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryAssetPurchaseWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryAssetPurchaseWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetPurchaseWithIdentifiableEntriesViewModel
   */
  cash_outgoings_change: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetPurchaseWithIdentifiableEntriesViewModel
   */
  purchase_change: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryAssetPurchaseWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryAssetPurchaseWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  cash_outgoings_change: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  purchase_change: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryAssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryAssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetPurchase: "asset_purchase",
  } as const;

export type MandatoryAssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryAssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryAssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryAssetSaleWithIdentifiableEntriesViewModel
 */
export interface MandatoryAssetSaleWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryAssetSaleWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryAssetSaleWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetSaleWithIdentifiableEntriesViewModel
   */
  proceeds_entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetSaleWithIdentifiableEntriesViewModel
   */
  sale_entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryAssetSaleWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryAssetSaleWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  proceeds_entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  sale_entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryAssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryAssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetSale: "asset_sale",
  } as const;

export type MandatoryAssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryAssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryAssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryAssetTradeWithIdentifiableEntriesViewModel
 */
export interface MandatoryAssetTradeWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryAssetTradeWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryAssetTradeWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetTradeWithIdentifiableEntriesViewModel
   */
  incoming_entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetTradeWithIdentifiableEntriesViewModel
   */
  outgoing_entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryAssetTradeWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryAssetTradeWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  incoming_entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  outgoing_entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryAssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryAssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetTrade: "asset_trade",
  } as const;

export type MandatoryAssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryAssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryAssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryAssetTransferInWithIdentifiableEntriesViewModel
 */
export interface MandatoryAssetTransferInWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryAssetTransferInWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryAssetTransferInWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetTransferInWithIdentifiableEntriesViewModel
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryAssetTransferInWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryAssetTransferInWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryAssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryAssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryAssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryAssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryAssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetTransferIn: "asset_transfer_in",
  } as const;

export type MandatoryAssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryAssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryAssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryAssetTransferOutWithIdentifiableEntriesViewModel
 */
export interface MandatoryAssetTransferOutWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryAssetTransferOutWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryAssetTransferOutWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetTransferOutWithIdentifiableEntriesViewModel
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryAssetTransferOutWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryAssetTransferOutWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryAssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryAssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryAssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryAssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryAssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryAssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetTransferOut: "asset_transfer_out",
  } as const;

export type MandatoryAssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryAssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryAssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryCashDividendWithIdentifiableEntriesViewModel
 */
export interface MandatoryCashDividendWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryCashDividendWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryCashDividendWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryCashDividendWithIdentifiableEntriesViewModel
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   * An id of a cash asset for which the dividends were paid for.
   * @type {number}
   * @memberof MandatoryCashDividendWithIdentifiableEntriesViewModel
   */
  origin_asset_id: number;
}
/**
 *
 * @export
 * @interface MandatoryCashDividendWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryCashDividendWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryCashDividendWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryCashDividendWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryCashDividendWithIdentifiableEntriesViewModelWithType
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   * An id of a cash asset for which the dividends were paid for.
   * @type {number}
   * @memberof MandatoryCashDividendWithIdentifiableEntriesViewModelWithType
   */
  origin_asset_id: number;
  /**
   *
   * @type {string}
   * @memberof MandatoryCashDividendWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryCashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryCashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    CashDividend: "cash_dividend",
  } as const;

export type MandatoryCashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryCashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryCashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryCashTransferInWithIdentifiableEntriesViewModel
 */
export interface MandatoryCashTransferInWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryCashTransferInWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryCashTransferInWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryCashTransferInWithIdentifiableEntriesViewModel
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryCashTransferInWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryCashTransferInWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryCashTransferInWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryCashTransferInWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryCashTransferInWithIdentifiableEntriesViewModelWithType
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryCashTransferInWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryCashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryCashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    CashTransferIn: "cash_transfer_in",
  } as const;

export type MandatoryCashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryCashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryCashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryCashTransferOutWithIdentifiableEntriesViewModel
 */
export interface MandatoryCashTransferOutWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryCashTransferOutWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryCashTransferOutWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryCashTransferOutWithIdentifiableEntriesViewModel
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryCashTransferOutWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryCashTransferOutWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryCashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryCashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryCashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryCashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryCashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryCashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    CashTransferOut: "cash_transfer_out",
  } as const;

export type MandatoryCashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryCashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryCashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryIdentifiableAccountAssetEntryViewModel
 */
export interface MandatoryIdentifiableAccountAssetEntryViewModel {
  /**
   * The id of an account for which to the entry is related.
   * @type {string}
   * @memberof MandatoryIdentifiableAccountAssetEntryViewModel
   */
  account_id: string;
  /**
   * The number of units of the asset that were added or removed from the account.
   * @type {number}
   * @memberof MandatoryIdentifiableAccountAssetEntryViewModel
   */
  amount: number;
  /**
   * The id of an asset in the account for which the entry is related.
   * @type {number}
   * @memberof MandatoryIdentifiableAccountAssetEntryViewModel
   */
  asset_id: number;
  /**
   * Id representing a single entry in a transaction.
   * @type {number}
   * @memberof MandatoryIdentifiableAccountAssetEntryViewModel
   */
  entry_id: number;
}
/**
 *
 * @export
 * @interface MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModel
 */
export interface MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModel
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModel
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModel
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModelWithType
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModelWithType
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AccountFees: "account_fees",
  } as const;

export type MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModel
 */
export interface MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  incoming_change: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModel
   */
  outgoing_change: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  incoming_change: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  outgoing_change: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetBalanceTransfer: "asset_balance_transfer",
  } as const;

export type MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModel
 */
export interface MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModel
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModel
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModel
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModelWithType
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModelWithType
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetDividend: "asset_dividend",
  } as const;

export type MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModel
 */
export interface MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModel
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModel
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModel
   */
  cash_outgoings_change: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModel
   */
  purchase_change: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  cash_outgoings_change: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  purchase_change: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetPurchase: "asset_purchase",
  } as const;

export type MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModel
 */
export interface MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModel
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModel
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModel
   */
  proceeds_entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModel
   */
  sale_entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  proceeds_entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  sale_entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetSale: "asset_sale",
  } as const;

export type MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModel
 */
export interface MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModel
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModel
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModel
   */
  incoming_entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModel
   */
  outgoing_entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  incoming_entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  outgoing_entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetTrade: "asset_trade",
  } as const;

export type MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModel
 */
export interface MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModel
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModel
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModel
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetTransferIn: "asset_transfer_in",
  } as const;

export type MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModel
 */
export interface MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModel
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModel
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModel
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    AssetTransferOut: "asset_transfer_out",
  } as const;

export type MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModel
 */
export interface MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModel
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModel
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModel
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   * An id of a cash asset for which the dividends were paid for.
   * @type {number}
   * @memberof MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModel
   */
  origin_asset_id: number;
}
/**
 *
 * @export
 * @interface MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModelWithType
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModelWithType
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   * An id of a cash asset for which the dividends were paid for.
   * @type {number}
   * @memberof MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModelWithType
   */
  origin_asset_id: number;
  /**
   *
   * @type {string}
   * @memberof MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    CashDividend: "cash_dividend",
  } as const;

export type MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModel
 */
export interface MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModel
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModel
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModel
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModelWithType
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModelWithType
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    CashTransferIn: "cash_transfer_in",
  } as const;

export type MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModel
 */
export interface MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModel
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModel
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModel
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  transaction_id: string;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    CashTransferOut: "cash_transfer_out",
  } as const;

export type MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModel
 */
export interface MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModel
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModel
   */
  transaction_id: string;
  /**
   * Specific bespoke category id.
   * @type {number}
   * @memberof MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModel
   */
  category_id: number;
  /**
   * Description of the transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModel
   */
  description?: string | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModel
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  transaction_id: string;
  /**
   * Specific bespoke category id.
   * @type {number}
   * @memberof MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  category_id: number;
  /**
   * Description of the transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  description?: string | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    RegularTransaction: "regular_transaction",
  } as const;

export type MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryIdentifiableTransactionBaseWithIdentifiableEntries
 */
export interface MandatoryIdentifiableTransactionBaseWithIdentifiableEntries {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryIdentifiableTransactionBaseWithIdentifiableEntries
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryIdentifiableTransactionBaseWithIdentifiableEntries
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
  /**
   * Id representing the full transaction.
   * @type {string}
   * @memberof MandatoryIdentifiableTransactionBaseWithIdentifiableEntries
   */
  transaction_id: string;
}
/**
 *
 * @export
 * @interface MandatoryIdentifiableTransactionFeeViewModel
 */
export interface MandatoryIdentifiableTransactionFeeViewModel {
  /**
   * The id of an account for which to the entry is related.
   * @type {string}
   * @memberof MandatoryIdentifiableTransactionFeeViewModel
   */
  account_id: string;
  /**
   * The number of units of the asset that were added or removed from the account.
   * @type {number}
   * @memberof MandatoryIdentifiableTransactionFeeViewModel
   */
  amount: number;
  /**
   * The id of an asset in the account for which the entry is related.
   * @type {number}
   * @memberof MandatoryIdentifiableTransactionFeeViewModel
   */
  asset_id: number;
  /**
   * Id representing a single entry in a transaction.
   * @type {number}
   * @memberof MandatoryIdentifiableTransactionFeeViewModel
   */
  entry_id: number;
  /**
   *
   * @type {TransactionFeeType}
   * @memberof MandatoryIdentifiableTransactionFeeViewModel
   */
  fee_type: TransactionFeeType;
}

/**
 *
 * @export
 * @interface MandatoryIdentifiableTransactionGroupViewModel
 */
export interface MandatoryIdentifiableTransactionGroupViewModel {
  /**
   * Overall category of whole group
   * @type {number}
   * @memberof MandatoryIdentifiableTransactionGroupViewModel
   */
  category_id: number;
  /**
   * Unrelated to individual transactions date which represent when the collection of transactions occurred
   * @type {string}
   * @memberof MandatoryIdentifiableTransactionGroupViewModel
   */
  date: number;
  /**
   * Overall description of whole group
   * @type {string}
   * @memberof MandatoryIdentifiableTransactionGroupViewModel
   */
  description: string;
  /**
   * All subtractions grouped into this group
   * @type {Array<MandatoryIdentifiableTransactionWithIdentifiableEntries>}
   * @memberof MandatoryIdentifiableTransactionGroupViewModel
   */
  transactions: Array<MandatoryIdentifiableTransactionWithIdentifiableEntries>;
  /**
   * Id representing a single entry in a transaction.
   * @type {number}
   * @memberof MandatoryIdentifiableTransactionGroupViewModel
   */
  group_id: number;
}
/**
 * @type MandatoryIdentifiableTransactionWithIdentifiableEntries
 * @export
 */
export type MandatoryIdentifiableTransactionWithIdentifiableEntries =
  | ({
      type: "account_fees";
    } & MandatoryIdentifiableAccountFeesWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_balance_transfer";
    } & MandatoryIdentifiableAssetBalanceTransferWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_dividend";
    } & MandatoryIdentifiableAssetDividendWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_purchase";
    } & MandatoryIdentifiableAssetPurchaseWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_sale";
    } & MandatoryIdentifiableAssetSaleWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_trade";
    } & MandatoryIdentifiableAssetTradeWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_transfer_in";
    } & MandatoryIdentifiableAssetTransferInWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_transfer_out";
    } & MandatoryIdentifiableAssetTransferOutWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "cash_dividend";
    } & MandatoryIdentifiableCashDividendWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "cash_transfer_in";
    } & MandatoryIdentifiableCashTransferInWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "cash_transfer_out";
    } & MandatoryIdentifiableCashTransferOutWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "regular_transaction";
    } & MandatoryIdentifiableRegularTransactionWithIdentifiableEntriesViewModelWithType);

/**
 *
 * @export
 * @interface MandatoryRegularTransactionWithIdentifiableEntriesViewModel
 */
export interface MandatoryRegularTransactionWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryRegularTransactionWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryRegularTransactionWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Specific bespoke category id.
   * @type {number}
   * @memberof MandatoryRegularTransactionWithIdentifiableEntriesViewModel
   */
  category_id: number;
  /**
   * Description of the transaction.
   * @type {string}
   * @memberof MandatoryRegularTransactionWithIdentifiableEntriesViewModel
   */
  description?: string | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryRegularTransactionWithIdentifiableEntriesViewModel
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface MandatoryRegularTransactionWithIdentifiableEntriesViewModelWithType
 */
export interface MandatoryRegularTransactionWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Specific bespoke category id.
   * @type {number}
   * @memberof MandatoryRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  category_id: number;
  /**
   * Description of the transaction.
   * @type {string}
   * @memberof MandatoryRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  description?: string | null;
  /**
   *
   * @type {MandatoryIdentifiableAccountAssetEntryViewModel}
   * @memberof MandatoryRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  entry: MandatoryIdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof MandatoryRegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  type: MandatoryRegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const MandatoryRegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    RegularTransaction: "regular_transaction",
  } as const;

export type MandatoryRegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof MandatoryRegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof MandatoryRegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface MandatoryTransactionBaseWithIdentifiableEntries
 */
export interface MandatoryTransactionBaseWithIdentifiableEntries {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof MandatoryTransactionBaseWithIdentifiableEntries
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<MandatoryIdentifiableTransactionFeeViewModel>}
   * @memberof MandatoryTransactionBaseWithIdentifiableEntries
   */
  fees?: Array<MandatoryIdentifiableTransactionFeeViewModel> | null;
}
/**
 *
 * @export
 * @interface MandatoryTransactionGroupViewModel
 */
export interface MandatoryTransactionGroupViewModel {
  /**
   * Overall category of whole group
   * @type {number}
   * @memberof MandatoryTransactionGroupViewModel
   */
  category_id: number;
  /**
   * Unrelated to individual transactions date which represent when the collection of transactions occurred
   * @type {string}
   * @memberof MandatoryTransactionGroupViewModel
   */
  date: number;
  /**
   * Overall description of whole group
   * @type {string}
   * @memberof MandatoryTransactionGroupViewModel
   */
  description: string;
  /**
   * All subtractions grouped into this group
   * @type {Array<MandatoryIdentifiableTransactionWithIdentifiableEntries>}
   * @memberof MandatoryTransactionGroupViewModel
   */
  transactions: Array<MandatoryIdentifiableTransactionWithIdentifiableEntries>;
}
/**
 * @type MandatoryTransactionWithIdentifiableEntries
 * @export
 */
export type MandatoryTransactionWithIdentifiableEntries =
  | ({
      type: "account_fees";
    } & MandatoryAccountFeesWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_balance_transfer";
    } & MandatoryAssetBalanceTransferWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_dividend";
    } & MandatoryAssetDividendWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_purchase";
    } & MandatoryAssetPurchaseWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_sale";
    } & MandatoryAssetSaleWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_trade";
    } & MandatoryAssetTradeWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_transfer_in";
    } & MandatoryAssetTransferInWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_transfer_out";
    } & MandatoryAssetTransferOutWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "cash_dividend";
    } & MandatoryCashDividendWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "cash_transfer_in";
    } & MandatoryCashTransferInWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "cash_transfer_out";
    } & MandatoryCashTransferOutWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "regular_transaction";
    } & MandatoryRegularTransactionWithIdentifiableEntriesViewModelWithType);

/**
 *
 * @export
 * @interface MetadataLookupTables
 */
export interface MetadataLookupTables {
  /**
   *
   * @type {Array<IdentifiableAccountViewModel>}
   * @memberof MetadataLookupTables
   */
  accounts: Array<IdentifiableAccountViewModel>;
  /**
   *
   * @type {Array<IdentifiableAssetViewModel>}
   * @memberof MetadataLookupTables
   */
  assets: Array<IdentifiableAssetViewModel>;
}
/**
 *
 * @export
 * @interface PageOfAssetsResultsWithLookupViewModel
 */
export interface PageOfAssetsResultsWithLookupViewModel {
  /**
   *
   * @type {AssetLookupTables}
   * @memberof PageOfAssetsResultsWithLookupViewModel
   */
  lookup_tables: AssetLookupTables;
  /**
   * One page of results
   * @type {Array<GetAssetsLineResponseViewModel>}
   * @memberof PageOfAssetsResultsWithLookupViewModel
   */
  results: Array<GetAssetsLineResponseViewModel>;
  /**
   * The total number of results available
   * @type {number}
   * @memberof PageOfAssetsResultsWithLookupViewModel
   */
  total_results: number;
}
/**
 *
 * @export
 * @interface PageOfIndividualTransactionsWithLookupViewModel
 */
export interface PageOfIndividualTransactionsWithLookupViewModel {
  /**
   *
   * @type {MetadataLookupTables}
   * @memberof PageOfIndividualTransactionsWithLookupViewModel
   */
  lookup_tables: MetadataLookupTables;
  /**
   * One page of results
   * @type {Array<MandatoryIdentifiableTransactionWithIdentifiableEntries>}
   * @memberof PageOfIndividualTransactionsWithLookupViewModel
   */
  results: Array<MandatoryIdentifiableTransactionWithIdentifiableEntries>;
  /**
   * The total number of results available
   * @type {number}
   * @memberof PageOfIndividualTransactionsWithLookupViewModel
   */
  total_results: number;
}
/**
 *
 * @export
 * @interface RegularTransactionViewModel
 */
export interface RegularTransactionViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof RegularTransactionViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof RegularTransactionViewModel
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   * Specific bespoke category id.
   * @type {number}
   * @memberof RegularTransactionViewModel
   */
  category_id: number;
  /**
   * Description of the transaction.
   * @type {string}
   * @memberof RegularTransactionViewModel
   */
  description?: string | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof RegularTransactionViewModel
   */
  entry: AccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface RegularTransactionViewModelWithType
 */
export interface RegularTransactionViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof RegularTransactionViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof RegularTransactionViewModelWithType
   */
  fees?: Array<TransactionFeeViewModel> | null;
  /**
   * Specific bespoke category id.
   * @type {number}
   * @memberof RegularTransactionViewModelWithType
   */
  category_id: number;
  /**
   * Description of the transaction.
   * @type {string}
   * @memberof RegularTransactionViewModelWithType
   */
  description?: string | null;
  /**
   *
   * @type {AccountAssetEntryViewModel}
   * @memberof RegularTransactionViewModelWithType
   */
  entry: AccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof RegularTransactionViewModelWithType
   */
  type: RegularTransactionViewModelWithTypeTypeEnum;
}

export const RegularTransactionViewModelWithTypeTypeEnum = {
  RegularTransaction: "regular_transaction",
} as const;

export type RegularTransactionViewModelWithTypeTypeEnum =
  (typeof RegularTransactionViewModelWithTypeTypeEnum)[keyof typeof RegularTransactionViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface RegularTransactionWithIdentifiableEntriesViewModel
 */
export interface RegularTransactionWithIdentifiableEntriesViewModel {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof RegularTransactionWithIdentifiableEntriesViewModel
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof RegularTransactionWithIdentifiableEntriesViewModel
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Specific bespoke category id.
   * @type {number}
   * @memberof RegularTransactionWithIdentifiableEntriesViewModel
   */
  category_id: number;
  /**
   * Description of the transaction.
   * @type {string}
   * @memberof RegularTransactionWithIdentifiableEntriesViewModel
   */
  description?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof RegularTransactionWithIdentifiableEntriesViewModel
   */
  entry: IdentifiableAccountAssetEntryViewModel;
}
/**
 *
 * @export
 * @interface RegularTransactionWithIdentifiableEntriesViewModelWithType
 */
export interface RegularTransactionWithIdentifiableEntriesViewModelWithType {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof RegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof RegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
  /**
   * Specific bespoke category id.
   * @type {number}
   * @memberof RegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  category_id: number;
  /**
   * Description of the transaction.
   * @type {string}
   * @memberof RegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  description?: string | null;
  /**
   *
   * @type {IdentifiableAccountAssetEntryViewModel}
   * @memberof RegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  entry: IdentifiableAccountAssetEntryViewModel;
  /**
   *
   * @type {string}
   * @memberof RegularTransactionWithIdentifiableEntriesViewModelWithType
   */
  type: RegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum;
}

export const RegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  {
    RegularTransaction: "regular_transaction",
  } as const;

export type RegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum =
  (typeof RegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum)[keyof typeof RegularTransactionWithIdentifiableEntriesViewModelWithTypeTypeEnum];

/**
 *
 * @export
 * @interface SharedAssetPairMetadataViewModel
 */
export interface SharedAssetPairMetadataViewModel {
  /**
   *
   * @type {string}
   * @memberof SharedAssetPairMetadataViewModel
   */
  last_updated: string;
  /**
   *
   * @type {number}
   * @memberof SharedAssetPairMetadataViewModel
   */
  latest_rate: number;
  /**
   *
   * @type {number}
   * @memberof SharedAssetPairMetadataViewModel
   */
  volume?: number | null;
}
/**
 *
 * @export
 * @interface TransactionBaseWithEntries
 */
export interface TransactionBaseWithEntries {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof TransactionBaseWithEntries
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<TransactionFeeViewModel>}
   * @memberof TransactionBaseWithEntries
   */
  fees?: Array<TransactionFeeViewModel> | null;
}
/**
 *
 * @export
 * @interface TransactionBaseWithIdentifiableEntries
 */
export interface TransactionBaseWithIdentifiableEntries {
  /**
   * Date when the transaction occured.
   * @type {string}
   * @memberof TransactionBaseWithIdentifiableEntries
   */
  date: number;
  /**
   * Any other fees related to the transaction, such as transfer or conversion fees.
   * @type {Array<IdentifiableTransactionFeeViewModel>}
   * @memberof TransactionBaseWithIdentifiableEntries
   */
  fees?: Array<IdentifiableTransactionFeeViewModel> | null;
}
/**
 *
 * @export
 * @enum {string}
 */

export const TransactionFeeType = {
  Transaction: "transaction",
  Exchange: "exchange",
} as const;

export type TransactionFeeType =
  (typeof TransactionFeeType)[keyof typeof TransactionFeeType];

/**
 *
 * @export
 * @interface TransactionFeeViewModel
 */
export interface TransactionFeeViewModel {
  /**
   * The id of an account for which to the entry is related.
   * @type {string}
   * @memberof TransactionFeeViewModel
   */
  account_id: string;
  /**
   * The number of units of the asset that were added or removed from the account.
   * @type {number}
   * @memberof TransactionFeeViewModel
   */
  amount: number;
  /**
   * The id of an asset in the account for which the entry is related.
   * @type {number}
   * @memberof TransactionFeeViewModel
   */
  asset_id: number;
  /**
   *
   * @type {TransactionFeeType}
   * @memberof TransactionFeeViewModel
   */
  fee_type: TransactionFeeType;
}

/**
 *
 * @export
 * @interface TransactionGroupViewModel
 */
export interface TransactionGroupViewModel {
  /**
   * Overall category of whole group
   * @type {number}
   * @memberof TransactionGroupViewModel
   */
  category_id: number;
  /**
   * Unrelated to individual transactions date which represent when the collection of transactions occurred
   * @type {string}
   * @memberof TransactionGroupViewModel
   */
  date: number;
  /**
   * Overall description of whole group
   * @type {string}
   * @memberof TransactionGroupViewModel
   */
  description: string;
  /**
   * All subtractions grouped into this group
   * @type {Array<TransactionWithEntries>}
   * @memberof TransactionGroupViewModel
   */
  transactions: Array<TransactionWithEntries>;
}
/**
 *
 * @export
 * @interface TransactionGroupWithIdentifiableChildrenViewModel
 */
export interface TransactionGroupWithIdentifiableChildrenViewModel {
  /**
   * Overall category of whole group
   * @type {number}
   * @memberof TransactionGroupWithIdentifiableChildrenViewModel
   */
  category_id: number;
  /**
   * Unrelated to individual transactions date which represent when the collection of transactions occurred
   * @type {string}
   * @memberof TransactionGroupWithIdentifiableChildrenViewModel
   */
  date: number;
  /**
   * Overall description of whole group
   * @type {string}
   * @memberof TransactionGroupWithIdentifiableChildrenViewModel
   */
  description: string;
  /**
   * All subtractions grouped into this group
   * @type {Array<IdentifiableTransactionWithIdentifiableEntries>}
   * @memberof TransactionGroupWithIdentifiableChildrenViewModel
   */
  transactions: Array<IdentifiableTransactionWithIdentifiableEntries>;
}
/**
 * @type TransactionWithEntries
 * @export
 */
export type TransactionWithEntries =
  | ({ type: "account_fees" } & AccountFeesViewModelWithType)
  | ({ type: "asset_balance_transfer" } & AssetBalanceTransferViewModelWithType)
  | ({ type: "asset_dividend" } & AssetDividendViewModelWithType)
  | ({ type: "asset_purchase" } & AssetPurchaseViewModelWithType)
  | ({ type: "asset_sale" } & AssetSaleViewModelWithType)
  | ({ type: "asset_trade" } & AssetTradeViewModelWithType)
  | ({ type: "asset_transfer_in" } & AssetTransferInViewModelWithType)
  | ({ type: "asset_transfer_out" } & AssetTransferOutViewModelWithType)
  | ({ type: "cash_dividend" } & CashDividendViewModelWithType)
  | ({ type: "cash_transfer_in" } & CashTransferInViewModelWithType)
  | ({ type: "cash_transfer_out" } & CashTransferOutViewModelWithType)
  | ({ type: "regular_transaction" } & RegularTransactionViewModelWithType);

/**
 * @type TransactionWithIdentifiableEntries
 * @export
 */
export type TransactionWithIdentifiableEntries =
  | ({
      type: "account_fees";
    } & AccountFeesWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_balance_transfer";
    } & AssetBalanceTransferWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_dividend";
    } & AssetDividendWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_purchase";
    } & AssetPurchaseWithIdentifiableEntriesViewModelWithType)
  | ({ type: "asset_sale" } & AssetSaleWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_trade";
    } & AssetTradeWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_transfer_in";
    } & AssetTransferInWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "asset_transfer_out";
    } & AssetTransferOutWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "cash_dividend";
    } & CashDividendWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "cash_transfer_in";
    } & CashTransferInWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "cash_transfer_out";
    } & CashTransferOutWithIdentifiableEntriesViewModelWithType)
  | ({
      type: "regular_transaction";
    } & RegularTransactionWithIdentifiableEntriesViewModelWithType);

/**
 *
 * @export
 * @interface UpdateAccountViewModel
 */
export interface UpdateAccountViewModel {
  /**
   *
   * @type {number}
   * @memberof UpdateAccountViewModel
   */
  account_type: number;
  /**
   *
   * @type {string}
   * @memberof UpdateAccountViewModel
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof UpdateAccountViewModel
   */
  liquidity_type: number;
}
/**
 *
 * @export
 * @interface UpdateAssetPairRequestViewModel
 */
export interface UpdateAssetPairRequestViewModel {
  /**
   *
   * @type {string}
   * @memberof UpdateAssetPairRequestViewModel
   */
  exchange: string;
}
/**
 *
 * @export
 * @interface UpdateAssetPairResponseViewModel
 */
export interface UpdateAssetPairResponseViewModel {
  /**
   *
   * @type {string}
   * @memberof UpdateAssetPairResponseViewModel
   */
  exchange: string;
}
/**
 *
 * @export
 * @interface UpdateAssetRequestViewModel
 */
export interface UpdateAssetRequestViewModel {
  /**
   *
   * @type {number}
   * @memberof UpdateAssetRequestViewModel
   */
  asset_type: number;
  /**
   *
   * @type {string}
   * @memberof UpdateAssetRequestViewModel
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof UpdateAssetRequestViewModel
   */
  ticker: string;
  /**
   *
   * @type {number}
   * @memberof UpdateAssetRequestViewModel
   */
  base_asset_id: number;
}
/**
 *
 * @export
 * @interface UpdateAssetResponseViewModel
 */
export interface UpdateAssetResponseViewModel {
  /**
   *
   * @type {number}
   * @memberof UpdateAssetResponseViewModel
   */
  asset_type: number;
  /**
   *
   * @type {string}
   * @memberof UpdateAssetResponseViewModel
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof UpdateAssetResponseViewModel
   */
  ticker: string;
  /**
   *
   * @type {number}
   * @memberof UpdateAssetResponseViewModel
   */
  base_asset_id: number;
}
/**
 *
 * @export
 * @interface UpdateIndividualTransactionRequestViewModel
 */
export interface UpdateIndividualTransactionRequestViewModel {
  /**
   *
   * @type {TransactionWithIdentifiableEntries}
   * @memberof UpdateIndividualTransactionRequestViewModel
   */
  transaction: TransactionWithIdentifiableEntries;
}
/**
 *
 * @export
 * @interface UpdateIndividualTransactionResponseViewModel
 */
export interface UpdateIndividualTransactionResponseViewModel {
  /**
   *
   * @type {Array<IdentifiableAccountViewModel>}
   * @memberof UpdateIndividualTransactionResponseViewModel
   */
  accounts: Array<IdentifiableAccountViewModel>;
  /**
   *
   * @type {Array<IdentifiableAssetViewModel>}
   * @memberof UpdateIndividualTransactionResponseViewModel
   */
  assets: Array<IdentifiableAssetViewModel>;
  /**
   *
   * @type {MandatoryTransactionWithIdentifiableEntries}
   * @memberof UpdateIndividualTransactionResponseViewModel
   */
  transaction: MandatoryTransactionWithIdentifiableEntries;
}
/**
 *
 * @export
 * @interface UpdateTransactionGroupRequestViewModel
 */
export interface UpdateTransactionGroupRequestViewModel {
  /**
   * Overall category of whole group
   * @type {number}
   * @memberof UpdateTransactionGroupRequestViewModel
   */
  category_id: number;
  /**
   * Unrelated to individual transactions date which represent when the collection of transactions occurred
   * @type {string}
   * @memberof UpdateTransactionGroupRequestViewModel
   */
  date: number;
  /**
   * Overall description of whole group
   * @type {string}
   * @memberof UpdateTransactionGroupRequestViewModel
   */
  description: string;
  /**
   * All subtractions grouped into this group
   * @type {Array<IdentifiableTransactionWithIdentifiableEntries>}
   * @memberof UpdateTransactionGroupRequestViewModel
   */
  transactions: Array<IdentifiableTransactionWithIdentifiableEntries>;
}
/**
 *
 * @export
 * @interface UpdateTransactionGroupResponseViewModel
 */
export interface UpdateTransactionGroupResponseViewModel {
  /**
   *
   * @type {Array<IdentifiableAccountViewModel>}
   * @memberof UpdateTransactionGroupResponseViewModel
   */
  accounts: Array<IdentifiableAccountViewModel>;
  /**
   *
   * @type {Array<IdentifiableAssetViewModel>}
   * @memberof UpdateTransactionGroupResponseViewModel
   */
  assets: Array<IdentifiableAssetViewModel>;
  /**
   *
   * @type {MandatoryTransactionGroupViewModel}
   * @memberof UpdateTransactionGroupResponseViewModel
   */
  group: MandatoryTransactionGroupViewModel;
}
/**
 *
 * @export
 * @interface UpdateTransactionRequestViewModel
 */
export interface UpdateTransactionRequestViewModel {
  /**
   *
   * @type {TransactionWithIdentifiableEntries}
   * @memberof UpdateTransactionRequestViewModel
   */
  transaction: TransactionWithIdentifiableEntries;
}
/**
 *
 * @export
 * @interface UpdateTransactionResponseViewModel
 */
export interface UpdateTransactionResponseViewModel {
  /**
   *
   * @type {Array<IdentifiableAccountViewModel>}
   * @memberof UpdateTransactionResponseViewModel
   */
  accounts: Array<IdentifiableAccountViewModel>;
  /**
   *
   * @type {Array<IdentifiableAssetViewModel>}
   * @memberof UpdateTransactionResponseViewModel
   */
  assets: Array<IdentifiableAssetViewModel>;
  /**
   *
   * @type {MandatoryTransactionWithIdentifiableEntries}
   * @memberof UpdateTransactionResponseViewModel
   */
  transaction: MandatoryTransactionWithIdentifiableEntries;
}
/**
 *
 * @export
 * @interface UserAssetPairMetadataViewModel
 */
export interface UserAssetPairMetadataViewModel {
  /**
   *
   * @type {string}
   * @memberof UserAssetPairMetadataViewModel
   */
  exchange: string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Adds a new account to the user.
     * @summary Add Account
     * @param {string} userId Unique Identifier of the user.
     * @param {AddAccountRequestViewModel} addAccountRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAccount: async (
      userId: string,
      addAccountRequestViewModel: AddAccountRequestViewModel,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("addAccount", "userId", userId);
      // verify required parameter 'addAccountRequestViewModel' is not null or undefined
      assertParamExists(
        "addAccount",
        "addAccountRequestViewModel",
        addAccountRequestViewModel
      );
      const localVarPath = `/api/users/{user_id}/accounts`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addAccountRequestViewModel,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Marks account as inactive so that its unavailable anymore.
     * @summary Delete Account
     * @param {string} userId Unique Identifier of the user.
     * @param {string} accountId Id of the account to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccount: async (
      userId: string,
      accountId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("deleteAccount", "userId", userId);
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists("deleteAccount", "accountId", accountId);
      const localVarPath = `/api/users/{user_id}/accounts/:account_id`
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
        .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a specific account of the user with metadata.
     * @summary Get Account
     * @param {string} userId Unique Identifier of the user.
     * @param {string} accountId Id of the account to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount: async (
      userId: string,
      accountId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getAccount", "userId", userId);
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists("getAccount", "accountId", accountId);
      const localVarPath = `/api/users/{user_id}/accounts/:account_id`
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
        .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves all available account liquidity types
     * @summary Get Account Liquidity Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountLiquidityTypes: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/accounts/liquiditytypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves all available account types
     * @summary Get Account Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountTypes: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/accounts/types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets all accounts and its metadata associated with user
     * @summary Get Accounts
     * @param {string} userId Unique Identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccounts: async (
      userId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getAccounts", "userId", userId);
      const localVarPath = `/api/users/{user_id}/accounts/`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates a specific account of the user with metadata.
     * @summary Update Account
     * @param {string} userId Unique Identifier of the user.
     * @param {string} accountId Id of the account to update.
     * @param {UpdateAccountViewModel} updateAccountViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccount: async (
      userId: string,
      accountId: string,
      updateAccountViewModel: UpdateAccountViewModel,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("updateAccount", "userId", userId);
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists("updateAccount", "accountId", accountId);
      // verify required parameter 'updateAccountViewModel' is not null or undefined
      assertParamExists(
        "updateAccount",
        "updateAccountViewModel",
        updateAccountViewModel
      );
      const localVarPath = `/api/users/{user_id}/accounts/:account_id`
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
        .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateAccountViewModel,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration);
  return {
    /**
     * Adds a new account to the user.
     * @summary Add Account
     * @param {string} userId Unique Identifier of the user.
     * @param {AddAccountRequestViewModel} addAccountRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addAccount(
      userId: string,
      addAccountRequestViewModel: AddAccountRequestViewModel,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AddAccountResponseViewModel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addAccount(
        userId,
        addAccountRequestViewModel,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AccountsApi.addAccount"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Marks account as inactive so that its unavailable anymore.
     * @summary Delete Account
     * @param {string} userId Unique Identifier of the user.
     * @param {string} accountId Id of the account to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAccount(
      userId: string,
      accountId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(
        userId,
        accountId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AccountsApi.deleteAccount"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Gets a specific account of the user with metadata.
     * @summary Get Account
     * @param {string} userId Unique Identifier of the user.
     * @param {string} accountId Id of the account to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccount(
      userId: string,
      accountId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetAccountResponseViewModel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(
        userId,
        accountId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AccountsApi.getAccount"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves all available account liquidity types
     * @summary Get Account Liquidity Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccountLiquidityTypes(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetAccountLiquidityTypesResponseViewModel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAccountLiquidityTypes(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AccountsApi.getAccountLiquidityTypes"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves all available account types
     * @summary Get Account Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccountTypes(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetAccountTypesResponseViewModel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAccountTypes(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AccountsApi.getAccountTypes"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Gets all accounts and its metadata associated with user
     * @summary Get Accounts
     * @param {string} userId Unique Identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccounts(
      userId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetAccountsResponseViewModel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(
        userId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AccountsApi.getAccounts"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Updates a specific account of the user with metadata.
     * @summary Update Account
     * @param {string} userId Unique Identifier of the user.
     * @param {string} accountId Id of the account to update.
     * @param {UpdateAccountViewModel} updateAccountViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateAccount(
      userId: string,
      accountId: string,
      updateAccountViewModel: UpdateAccountViewModel,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateAccountViewModel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(
        userId,
        accountId,
        updateAccountViewModel,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AccountsApi.updateAccount"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AccountsApiFp(configuration);
  return {
    /**
     * Adds a new account to the user.
     * @summary Add Account
     * @param {string} userId Unique Identifier of the user.
     * @param {AddAccountRequestViewModel} addAccountRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAccount(
      userId: string,
      addAccountRequestViewModel: AddAccountRequestViewModel,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AddAccountResponseViewModel> {
      return localVarFp
        .addAccount(userId, addAccountRequestViewModel, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Marks account as inactive so that its unavailable anymore.
     * @summary Delete Account
     * @param {string} userId Unique Identifier of the user.
     * @param {string} accountId Id of the account to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccount(
      userId: string,
      accountId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .deleteAccount(userId, accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets a specific account of the user with metadata.
     * @summary Get Account
     * @param {string} userId Unique Identifier of the user.
     * @param {string} accountId Id of the account to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(
      userId: string,
      accountId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetAccountResponseViewModel> {
      return localVarFp
        .getAccount(userId, accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves all available account liquidity types
     * @summary Get Account Liquidity Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountLiquidityTypes(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetAccountLiquidityTypesResponseViewModel> {
      return localVarFp
        .getAccountLiquidityTypes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves all available account types
     * @summary Get Account Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountTypes(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetAccountTypesResponseViewModel> {
      return localVarFp
        .getAccountTypes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets all accounts and its metadata associated with user
     * @summary Get Accounts
     * @param {string} userId Unique Identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccounts(
      userId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetAccountsResponseViewModel> {
      return localVarFp
        .getAccounts(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates a specific account of the user with metadata.
     * @summary Update Account
     * @param {string} userId Unique Identifier of the user.
     * @param {string} accountId Id of the account to update.
     * @param {UpdateAccountViewModel} updateAccountViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccount(
      userId: string,
      accountId: string,
      updateAccountViewModel: UpdateAccountViewModel,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateAccountViewModel> {
      return localVarFp
        .updateAccount(userId, accountId, updateAccountViewModel, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
  /**
   * Adds a new account to the user.
   * @summary Add Account
   * @param {string} userId Unique Identifier of the user.
   * @param {AddAccountRequestViewModel} addAccountRequestViewModel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public addAccount(
    userId: string,
    addAccountRequestViewModel: AddAccountRequestViewModel,
    options?: RawAxiosRequestConfig
  ) {
    return AccountsApiFp(this.configuration)
      .addAccount(userId, addAccountRequestViewModel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Marks account as inactive so that its unavailable anymore.
   * @summary Delete Account
   * @param {string} userId Unique Identifier of the user.
   * @param {string} accountId Id of the account to delete.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public deleteAccount(
    userId: string,
    accountId: string,
    options?: RawAxiosRequestConfig
  ) {
    return AccountsApiFp(this.configuration)
      .deleteAccount(userId, accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets a specific account of the user with metadata.
   * @summary Get Account
   * @param {string} userId Unique Identifier of the user.
   * @param {string} accountId Id of the account to retrieve.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getAccount(
    userId: string,
    accountId: string,
    options?: RawAxiosRequestConfig
  ) {
    return AccountsApiFp(this.configuration)
      .getAccount(userId, accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves all available account liquidity types
   * @summary Get Account Liquidity Types
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getAccountLiquidityTypes(options?: RawAxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .getAccountLiquidityTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves all available account types
   * @summary Get Account Types
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getAccountTypes(options?: RawAxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .getAccountTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets all accounts and its metadata associated with user
   * @summary Get Accounts
   * @param {string} userId Unique Identifier of the user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getAccounts(userId: string, options?: RawAxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .getAccounts(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates a specific account of the user with metadata.
   * @summary Update Account
   * @param {string} userId Unique Identifier of the user.
   * @param {string} accountId Id of the account to update.
   * @param {UpdateAccountViewModel} updateAccountViewModel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public updateAccount(
    userId: string,
    accountId: string,
    updateAccountViewModel: UpdateAccountViewModel,
    options?: RawAxiosRequestConfig
  ) {
    return AccountsApiFp(this.configuration)
      .updateAccount(userId, accountId, updateAccountViewModel, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Gets a shared asset.
     * @summary Get asset
     * @param {number} assetId Id of the shared asset to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAsset: async (
      assetId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'assetId' is not null or undefined
      assertParamExists("getAsset", "assetId", assetId);
      const localVarPath = `/api/assets/:asset_id`.replace(
        `{${"asset_id"}}`,
        encodeURIComponent(String(assetId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets asset pair and its metadata.
     * @summary Get asset pair
     * @param {number} assetId Id of the shared asset to retrieve.
     * @param {number} referenceId Id of the reference asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssetPair: async (
      assetId: number,
      referenceId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'assetId' is not null or undefined
      assertParamExists("getAssetPair", "assetId", assetId);
      // verify required parameter 'referenceId' is not null or undefined
      assertParamExists("getAssetPair", "referenceId", referenceId);
      const localVarPath = `/api/assets/:asset_id/:reference_id`
        .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)))
        .replace(
          `{${"reference_id"}}`,
          encodeURIComponent(String(referenceId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets asset pair rates based on provided query params
     * @summary Get asset pair rates
     * @param {number} assetId Id of the shared asset to retrieve.
     * @param {number} referenceId Id of the reference asset.
     * @param {string} [range] The range time for which to retrieve the rates for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssetPairRates: async (
      assetId: number,
      referenceId: number,
      range?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'assetId' is not null or undefined
      assertParamExists("getAssetPairRates", "assetId", assetId);
      // verify required parameter 'referenceId' is not null or undefined
      assertParamExists("getAssetPairRates", "referenceId", referenceId);
      const localVarPath = `/api/assets/:asset_id/:reference_id/rates`
        .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)))
        .replace(
          `{${"reference_id"}}`,
          encodeURIComponent(String(referenceId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (range !== undefined) {
        localVarQueryParameter["range"] = range;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query to search shared assets. Returns a page of results. If not query parameters are provided, returns results sorted by most popular. The equivalent search endpoint for the user assets is not provided, as user assets can be retrieved in full due to it being a small subset.
     * @summary Search assets
     * @param {number} [count] How many items to return in a single page
     * @param {number} [start] The index in the list of the fist element of the page.
     * @param {string | null} [query] The search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAssets: async (
      count?: number,
      start?: number,
      query?: string | null,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/assets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (count !== undefined) {
        localVarQueryParameter["count"] = count;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration);
  return {
    /**
     * Gets a shared asset.
     * @summary Get asset
     * @param {number} assetId Id of the shared asset to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAsset(
      assetId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetAssetResponseViewModel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(
        assetId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AssetsApi.getAsset"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Gets asset pair and its metadata.
     * @summary Get asset pair
     * @param {number} assetId Id of the shared asset to retrieve.
     * @param {number} referenceId Id of the reference asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAssetPair(
      assetId: number,
      referenceId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetAssetPairResponseViewModel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetPair(
        assetId,
        referenceId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AssetsApi.getAssetPair"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Gets asset pair rates based on provided query params
     * @summary Get asset pair rates
     * @param {number} assetId Id of the shared asset to retrieve.
     * @param {number} referenceId Id of the reference asset.
     * @param {string} [range] The range time for which to retrieve the rates for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAssetPairRates(
      assetId: number,
      referenceId: number,
      range?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetAssetPairRatesResponseViewModel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAssetPairRates(
          assetId,
          referenceId,
          range,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AssetsApi.getAssetPairRates"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Query to search shared assets. Returns a page of results. If not query parameters are provided, returns results sorted by most popular. The equivalent search endpoint for the user assets is not provided, as user assets can be retrieved in full due to it being a small subset.
     * @summary Search assets
     * @param {number} [count] How many items to return in a single page
     * @param {number} [start] The index in the list of the fist element of the page.
     * @param {string | null} [query] The search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAssets(
      count?: number,
      start?: number,
      query?: string | null,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageOfAssetsResultsWithLookupViewModel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchAssets(
        count,
        start,
        query,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AssetsApi.searchAssets"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AssetsApiFp(configuration);
  return {
    /**
     * Gets a shared asset.
     * @summary Get asset
     * @param {number} assetId Id of the shared asset to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAsset(
      assetId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetAssetResponseViewModel> {
      return localVarFp
        .getAsset(assetId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets asset pair and its metadata.
     * @summary Get asset pair
     * @param {number} assetId Id of the shared asset to retrieve.
     * @param {number} referenceId Id of the reference asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssetPair(
      assetId: number,
      referenceId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetAssetPairResponseViewModel> {
      return localVarFp
        .getAssetPair(assetId, referenceId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets asset pair rates based on provided query params
     * @summary Get asset pair rates
     * @param {number} assetId Id of the shared asset to retrieve.
     * @param {number} referenceId Id of the reference asset.
     * @param {string} [range] The range time for which to retrieve the rates for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssetPairRates(
      assetId: number,
      referenceId: number,
      range?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetAssetPairRatesResponseViewModel> {
      return localVarFp
        .getAssetPairRates(assetId, referenceId, range, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Query to search shared assets. Returns a page of results. If not query parameters are provided, returns results sorted by most popular. The equivalent search endpoint for the user assets is not provided, as user assets can be retrieved in full due to it being a small subset.
     * @summary Search assets
     * @param {number} [count] How many items to return in a single page
     * @param {number} [start] The index in the list of the fist element of the page.
     * @param {string | null} [query] The search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAssets(
      count?: number,
      start?: number,
      query?: string | null,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageOfAssetsResultsWithLookupViewModel> {
      return localVarFp
        .searchAssets(count, start, query, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
  /**
   * Gets a shared asset.
   * @summary Get asset
   * @param {number} assetId Id of the shared asset to retrieve.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetsApi
   */
  public getAsset(assetId: number, options?: RawAxiosRequestConfig) {
    return AssetsApiFp(this.configuration)
      .getAsset(assetId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets asset pair and its metadata.
   * @summary Get asset pair
   * @param {number} assetId Id of the shared asset to retrieve.
   * @param {number} referenceId Id of the reference asset.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetsApi
   */
  public getAssetPair(
    assetId: number,
    referenceId: number,
    options?: RawAxiosRequestConfig
  ) {
    return AssetsApiFp(this.configuration)
      .getAssetPair(assetId, referenceId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets asset pair rates based on provided query params
   * @summary Get asset pair rates
   * @param {number} assetId Id of the shared asset to retrieve.
   * @param {number} referenceId Id of the reference asset.
   * @param {string} [range] The range time for which to retrieve the rates for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetsApi
   */
  public getAssetPairRates(
    assetId: number,
    referenceId: number,
    range?: string,
    options?: RawAxiosRequestConfig
  ) {
    return AssetsApiFp(this.configuration)
      .getAssetPairRates(assetId, referenceId, range, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Query to search shared assets. Returns a page of results. If not query parameters are provided, returns results sorted by most popular. The equivalent search endpoint for the user assets is not provided, as user assets can be retrieved in full due to it being a small subset.
   * @summary Search assets
   * @param {number} [count] How many items to return in a single page
   * @param {number} [start] The index in the list of the fist element of the page.
   * @param {string | null} [query] The search query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetsApi
   */
  public searchAssets(
    count?: number,
    start?: number,
    query?: string | null,
    options?: RawAxiosRequestConfig
  ) {
    return AssetsApiFp(this.configuration)
      .searchAssets(count, start, query, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Posting login details to this query will return an authentication token used in most of the requests.
     * @summary Authenticate
     * @param {LoginDetailsViewModel} loginDetailsViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLoginDetails: async (
      loginDetailsViewModel: LoginDetailsViewModel,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginDetailsViewModel' is not null or undefined
      assertParamExists(
        "postLoginDetails",
        "loginDetailsViewModel",
        loginDetailsViewModel
      );
      const localVarPath = `/api/auth`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginDetailsViewModel,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    AuthenticationApiAxiosParamCreator(configuration);
  return {
    /**
     * Posting login details to this query will return an authentication token used in most of the requests.
     * @summary Authenticate
     * @param {LoginDetailsViewModel} loginDetailsViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postLoginDetails(
      loginDetailsViewModel: LoginDetailsViewModel,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthViewModel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postLoginDetails(
          loginDetailsViewModel,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthenticationApi.postLoginDetails"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthenticationApiFp(configuration);
  return {
    /**
     * Posting login details to this query will return an authentication token used in most of the requests.
     * @summary Authenticate
     * @param {LoginDetailsViewModel} loginDetailsViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLoginDetails(
      loginDetailsViewModel: LoginDetailsViewModel,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AuthViewModel> {
      return localVarFp
        .postLoginDetails(loginDetailsViewModel, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
  /**
   * Posting login details to this query will return an authentication token used in most of the requests.
   * @summary Authenticate
   * @param {LoginDetailsViewModel} loginDetailsViewModel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public postLoginDetails(
    loginDetailsViewModel: LoginDetailsViewModel,
    options?: RawAxiosRequestConfig
  ) {
    return AuthenticationApiFp(this.configuration)
      .postLoginDetails(loginDetailsViewModel, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * IndividualTransactionsApi - axios parameter creator
 * @export
 */
export const IndividualTransactionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Adds a new individual transaction.
     * @summary Add new
     * @param {string} userId User Id for which to add the individual transaction for.
     * @param {AddIndividualTransactionRequestViewModel} addIndividualTransactionRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addIndividualTransaction: async (
      userId: string,
      addIndividualTransactionRequestViewModel: AddIndividualTransactionRequestViewModel,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("addIndividualTransaction", "userId", userId);
      // verify required parameter 'addIndividualTransactionRequestViewModel' is not null or undefined
      assertParamExists(
        "addIndividualTransaction",
        "addIndividualTransactionRequestViewModel",
        addIndividualTransactionRequestViewModel
      );
      const localVarPath =
        `/api/users/{user_id}/transactions/individual`.replace(
          `{${"user_id"}}`,
          encodeURIComponent(String(userId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addIndividualTransactionRequestViewModel,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a list of all individual transactions
     * @summary Get all
     * @param {string} userId User id for which the transactions group belongs to.
     * @param {number} [count] How many items to return in a single page
     * @param {number} [start] The index in the list of the fist element of the page.
     * @param {string | null} [query] The search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIndividualTransactions: async (
      userId: string,
      count?: number,
      start?: number,
      query?: string | null,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getIndividualTransactions", "userId", userId);
      const localVarPath =
        `/api/users/{user_id}/transactions/individual`.replace(
          `{${"user_id"}}`,
          encodeURIComponent(String(userId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (count !== undefined) {
        localVarQueryParameter["count"] = count;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a single transaction by specified id
     * @summary Get Single
     * @param {string} userId User id for which the transactions group belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingle: async (
      userId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getSingle", "userId", userId);
      const localVarPath =
        `/api/users/{user_id}/transactions/individual/:transaction_id`.replace(
          `{${"user_id"}}`,
          encodeURIComponent(String(userId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Performs an update of an individual transaction. If the transaction provided is not individual, it will be moved to individual and removed from other group.
     * @summary Update existing
     * @param {string} userId User id for which the individual transaction belongs to.
     * @param {string} transactionId The id of the specific individual transaction which is being updated.
     * @param {UpdateIndividualTransactionRequestViewModel} updateIndividualTransactionRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAnExistingIndividualTransaction: async (
      userId: string,
      transactionId: string,
      updateIndividualTransactionRequestViewModel: UpdateIndividualTransactionRequestViewModel,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists(
        "updateAnExistingIndividualTransaction",
        "userId",
        userId
      );
      // verify required parameter 'transactionId' is not null or undefined
      assertParamExists(
        "updateAnExistingIndividualTransaction",
        "transactionId",
        transactionId
      );
      // verify required parameter 'updateIndividualTransactionRequestViewModel' is not null or undefined
      assertParamExists(
        "updateAnExistingIndividualTransaction",
        "updateIndividualTransactionRequestViewModel",
        updateIndividualTransactionRequestViewModel
      );
      const localVarPath =
        `/api/users/{user_id}/transactions/individual/:transaction_id`
          .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
          .replace(
            `{${"transaction_id"}}`,
            encodeURIComponent(String(transactionId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateIndividualTransactionRequestViewModel,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IndividualTransactionsApi - functional programming interface
 * @export
 */
export const IndividualTransactionsApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    IndividualTransactionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Adds a new individual transaction.
     * @summary Add new
     * @param {string} userId User Id for which to add the individual transaction for.
     * @param {AddIndividualTransactionRequestViewModel} addIndividualTransactionRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addIndividualTransaction(
      userId: string,
      addIndividualTransactionRequestViewModel: AddIndividualTransactionRequestViewModel,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AddIndividualTransactionResponseViewModel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addIndividualTransaction(
          userId,
          addIndividualTransactionRequestViewModel,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "IndividualTransactionsApi.addIndividualTransaction"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves a list of all individual transactions
     * @summary Get all
     * @param {string} userId User id for which the transactions group belongs to.
     * @param {number} [count] How many items to return in a single page
     * @param {number} [start] The index in the list of the fist element of the page.
     * @param {string | null} [query] The search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIndividualTransactions(
      userId: string,
      count?: number,
      start?: number,
      query?: string | null,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageOfIndividualTransactionsWithLookupViewModel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getIndividualTransactions(
          userId,
          count,
          start,
          query,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "IndividualTransactionsApi.getIndividualTransactions"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves a single transaction by specified id
     * @summary Get Single
     * @param {string} userId User id for which the transactions group belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSingle(
      userId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetIndividualTransactionViewModel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSingle(
        userId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["IndividualTransactionsApi.getSingle"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Performs an update of an individual transaction. If the transaction provided is not individual, it will be moved to individual and removed from other group.
     * @summary Update existing
     * @param {string} userId User id for which the individual transaction belongs to.
     * @param {string} transactionId The id of the specific individual transaction which is being updated.
     * @param {UpdateIndividualTransactionRequestViewModel} updateIndividualTransactionRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateAnExistingIndividualTransaction(
      userId: string,
      transactionId: string,
      updateIndividualTransactionRequestViewModel: UpdateIndividualTransactionRequestViewModel,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateIndividualTransactionResponseViewModel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateAnExistingIndividualTransaction(
          userId,
          transactionId,
          updateIndividualTransactionRequestViewModel,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "IndividualTransactionsApi.updateAnExistingIndividualTransaction"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * IndividualTransactionsApi - factory interface
 * @export
 */
export const IndividualTransactionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = IndividualTransactionsApiFp(configuration);
  return {
    /**
     * Adds a new individual transaction.
     * @summary Add new
     * @param {string} userId User Id for which to add the individual transaction for.
     * @param {AddIndividualTransactionRequestViewModel} addIndividualTransactionRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addIndividualTransaction(
      userId: string,
      addIndividualTransactionRequestViewModel: AddIndividualTransactionRequestViewModel,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AddIndividualTransactionResponseViewModel> {
      return localVarFp
        .addIndividualTransaction(
          userId,
          addIndividualTransactionRequestViewModel,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a list of all individual transactions
     * @summary Get all
     * @param {string} userId User id for which the transactions group belongs to.
     * @param {number} [count] How many items to return in a single page
     * @param {number} [start] The index in the list of the fist element of the page.
     * @param {string | null} [query] The search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIndividualTransactions(
      userId: string,
      count?: number,
      start?: number,
      query?: string | null,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageOfIndividualTransactionsWithLookupViewModel> {
      return localVarFp
        .getIndividualTransactions(userId, count, start, query, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a single transaction by specified id
     * @summary Get Single
     * @param {string} userId User id for which the transactions group belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingle(
      userId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetIndividualTransactionViewModel> {
      return localVarFp
        .getSingle(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Performs an update of an individual transaction. If the transaction provided is not individual, it will be moved to individual and removed from other group.
     * @summary Update existing
     * @param {string} userId User id for which the individual transaction belongs to.
     * @param {string} transactionId The id of the specific individual transaction which is being updated.
     * @param {UpdateIndividualTransactionRequestViewModel} updateIndividualTransactionRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAnExistingIndividualTransaction(
      userId: string,
      transactionId: string,
      updateIndividualTransactionRequestViewModel: UpdateIndividualTransactionRequestViewModel,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateIndividualTransactionResponseViewModel> {
      return localVarFp
        .updateAnExistingIndividualTransaction(
          userId,
          transactionId,
          updateIndividualTransactionRequestViewModel,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * IndividualTransactionsApi - object-oriented interface
 * @export
 * @class IndividualTransactionsApi
 * @extends {BaseAPI}
 */
export class IndividualTransactionsApi extends BaseAPI {
  /**
   * Adds a new individual transaction.
   * @summary Add new
   * @param {string} userId User Id for which to add the individual transaction for.
   * @param {AddIndividualTransactionRequestViewModel} addIndividualTransactionRequestViewModel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IndividualTransactionsApi
   */
  public addIndividualTransaction(
    userId: string,
    addIndividualTransactionRequestViewModel: AddIndividualTransactionRequestViewModel,
    options?: RawAxiosRequestConfig
  ) {
    return IndividualTransactionsApiFp(this.configuration)
      .addIndividualTransaction(
        userId,
        addIndividualTransactionRequestViewModel,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves a list of all individual transactions
   * @summary Get all
   * @param {string} userId User id for which the transactions group belongs to.
   * @param {number} [count] How many items to return in a single page
   * @param {number} [start] The index in the list of the fist element of the page.
   * @param {string | null} [query] The search query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IndividualTransactionsApi
   */
  public getIndividualTransactions(
    userId: string,
    count?: number,
    start?: number,
    query?: string | null,
    options?: RawAxiosRequestConfig
  ) {
    return IndividualTransactionsApiFp(this.configuration)
      .getIndividualTransactions(userId, count, start, query, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves a single transaction by specified id
   * @summary Get Single
   * @param {string} userId User id for which the transactions group belongs to.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IndividualTransactionsApi
   */
  public getSingle(userId: string, options?: RawAxiosRequestConfig) {
    return IndividualTransactionsApiFp(this.configuration)
      .getSingle(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Performs an update of an individual transaction. If the transaction provided is not individual, it will be moved to individual and removed from other group.
   * @summary Update existing
   * @param {string} userId User id for which the individual transaction belongs to.
   * @param {string} transactionId The id of the specific individual transaction which is being updated.
   * @param {UpdateIndividualTransactionRequestViewModel} updateIndividualTransactionRequestViewModel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IndividualTransactionsApi
   */
  public updateAnExistingIndividualTransaction(
    userId: string,
    transactionId: string,
    updateIndividualTransactionRequestViewModel: UpdateIndividualTransactionRequestViewModel,
    options?: RawAxiosRequestConfig
  ) {
    return IndividualTransactionsApiFp(this.configuration)
      .updateAnExistingIndividualTransaction(
        userId,
        transactionId,
        updateIndividualTransactionRequestViewModel,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PortfolioApi - axios parameter creator
 * @export
 */
export const PortfolioApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns a list of assets that user holds and their current value.
     * @summary Get Holdings
     * @param {string} userId User id for who to retrieve holdings
     * @param {number | null} [defaultAssetId] Default asset id to use for retrieving current value of units. If not provided, the default asset id from the user will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHoldings: async (
      userId: string,
      defaultAssetId?: number | null,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getHoldings", "userId", userId);
      const localVarPath = `/api/users/{user_id}/portfolio/holdings`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (defaultAssetId !== undefined) {
        localVarQueryParameter["default_asset_id"] = defaultAssetId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of net worth of an user at specific points in time, depending on the range provided.
     * @summary Get Net Worth History
     * @param {string} userId User id for who to retrieve net worth history
     * @param {string} [range] The range time for which to retrieve the sums for
     * @param {number | null} [defaultAssetId] The default asset id to use for retrieving current value of units. If not provided, the default asset id from the user will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNetworthHistory: async (
      userId: string,
      range?: string,
      defaultAssetId?: number | null,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getNetworthHistory", "userId", userId);
      const localVarPath = `/api/users/{user_id}/portfolio/history`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (range !== undefined) {
        localVarQueryParameter["range"] = range;
      }

      if (defaultAssetId !== undefined) {
        localVarQueryParameter["default_asset_id"] = defaultAssetId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PortfolioApi - functional programming interface
 * @export
 */
export const PortfolioApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PortfolioApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns a list of assets that user holds and their current value.
     * @summary Get Holdings
     * @param {string} userId User id for who to retrieve holdings
     * @param {number | null} [defaultAssetId] Default asset id to use for retrieving current value of units. If not provided, the default asset id from the user will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHoldings(
      userId: string,
      defaultAssetId?: number | null,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetHoldingsResponseViewModel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getHoldings(
        userId,
        defaultAssetId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PortfolioApi.getHoldings"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a list of net worth of an user at specific points in time, depending on the range provided.
     * @summary Get Net Worth History
     * @param {string} userId User id for who to retrieve net worth history
     * @param {string} [range] The range time for which to retrieve the sums for
     * @param {number | null} [defaultAssetId] The default asset id to use for retrieving current value of units. If not provided, the default asset id from the user will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getNetworthHistory(
      userId: string,
      range?: string,
      defaultAssetId?: number | null,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetNetWorthHistoryResponseViewModel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getNetworthHistory(
          userId,
          range,
          defaultAssetId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PortfolioApi.getNetworthHistory"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * PortfolioApi - factory interface
 * @export
 */
export const PortfolioApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PortfolioApiFp(configuration);
  return {
    /**
     * Returns a list of assets that user holds and their current value.
     * @summary Get Holdings
     * @param {string} userId User id for who to retrieve holdings
     * @param {number | null} [defaultAssetId] Default asset id to use for retrieving current value of units. If not provided, the default asset id from the user will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHoldings(
      userId: string,
      defaultAssetId?: number | null,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetHoldingsResponseViewModel> {
      return localVarFp
        .getHoldings(userId, defaultAssetId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of net worth of an user at specific points in time, depending on the range provided.
     * @summary Get Net Worth History
     * @param {string} userId User id for who to retrieve net worth history
     * @param {string} [range] The range time for which to retrieve the sums for
     * @param {number | null} [defaultAssetId] The default asset id to use for retrieving current value of units. If not provided, the default asset id from the user will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNetworthHistory(
      userId: string,
      range?: string,
      defaultAssetId?: number | null,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetNetWorthHistoryResponseViewModel> {
      return localVarFp
        .getNetworthHistory(userId, range, defaultAssetId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PortfolioApi - object-oriented interface
 * @export
 * @class PortfolioApi
 * @extends {BaseAPI}
 */
export class PortfolioApi extends BaseAPI {
  /**
   * Returns a list of assets that user holds and their current value.
   * @summary Get Holdings
   * @param {string} userId User id for who to retrieve holdings
   * @param {number | null} [defaultAssetId] Default asset id to use for retrieving current value of units. If not provided, the default asset id from the user will be used
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioApi
   */
  public getHoldings(
    userId: string,
    defaultAssetId?: number | null,
    options?: RawAxiosRequestConfig
  ) {
    return PortfolioApiFp(this.configuration)
      .getHoldings(userId, defaultAssetId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of net worth of an user at specific points in time, depending on the range provided.
   * @summary Get Net Worth History
   * @param {string} userId User id for who to retrieve net worth history
   * @param {string} [range] The range time for which to retrieve the sums for
   * @param {number | null} [defaultAssetId] The default asset id to use for retrieving current value of units. If not provided, the default asset id from the user will be used
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioApi
   */
  public getNetworthHistory(
    userId: string,
    range?: string,
    defaultAssetId?: number | null,
    options?: RawAxiosRequestConfig
  ) {
    return PortfolioApiFp(this.configuration)
      .getNetworthHistory(userId, range, defaultAssetId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TransactionGroupsApi - axios parameter creator
 * @export
 */
export const TransactionGroupsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Adds a group of transactions with metadata related to all of them.
     * @summary Add new
     * @param {string} userId User Id for which to add the transaction group for.
     * @param {AddTransactionGroupRequestViewModel} addTransactionGroupRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTransactionGroup: async (
      userId: string,
      addTransactionGroupRequestViewModel: AddTransactionGroupRequestViewModel,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("addTransactionGroup", "userId", userId);
      // verify required parameter 'addTransactionGroupRequestViewModel' is not null or undefined
      assertParamExists(
        "addTransactionGroup",
        "addTransactionGroupRequestViewModel",
        addTransactionGroupRequestViewModel
      );
      const localVarPath = `/api/users/{user_id}/transactions/groups`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addTransactionGroupRequestViewModel,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes the entire transaction group and associated transactions within it.
     * @summary Delete existing
     * @param {string} userId User id for which the transaction group belongs to.
     * @param {number} groupId The Id of the transaction group to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAnExistingTransactionGroup: async (
      userId: string,
      groupId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("deleteAnExistingTransactionGroup", "userId", userId);
      // verify required parameter 'groupId' is not null or undefined
      assertParamExists("deleteAnExistingTransactionGroup", "groupId", groupId);
      const localVarPath = `/api/users/{user_id}/transactions/groups/:group_id`
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
        .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a list of all individual transactions
     * @summary Get all
     * @param {string} userId User id for which the transaction group belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionGroups: async (
      userId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getTransactionGroups", "userId", userId);
      const localVarPath = `/api/users/{user_id}/transactions/groups`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * If the transactions array is updated with an existing transaction id, that transaction will be moved from individual to a group.
     * @summary Update existing
     * @param {string} userId User id for which the transaction group belongs to.
     * @param {number} groupId The id of the transaction group which is being updated.
     * @param {UpdateTransactionGroupRequestViewModel} updateTransactionGroupRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTransactionGroup: async (
      userId: string,
      groupId: number,
      updateTransactionGroupRequestViewModel: UpdateTransactionGroupRequestViewModel,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("updateTransactionGroup", "userId", userId);
      // verify required parameter 'groupId' is not null or undefined
      assertParamExists("updateTransactionGroup", "groupId", groupId);
      // verify required parameter 'updateTransactionGroupRequestViewModel' is not null or undefined
      assertParamExists(
        "updateTransactionGroup",
        "updateTransactionGroupRequestViewModel",
        updateTransactionGroupRequestViewModel
      );
      const localVarPath = `/api/users/{user_id}/transactions/groups/:group_id`
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
        .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateTransactionGroupRequestViewModel,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TransactionGroupsApi - functional programming interface
 * @export
 */
export const TransactionGroupsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TransactionGroupsApiAxiosParamCreator(configuration);
  return {
    /**
     * Adds a group of transactions with metadata related to all of them.
     * @summary Add new
     * @param {string} userId User Id for which to add the transaction group for.
     * @param {AddTransactionGroupRequestViewModel} addTransactionGroupRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTransactionGroup(
      userId: string,
      addTransactionGroupRequestViewModel: AddTransactionGroupRequestViewModel,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AddTransactionGroupResponseViewModel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addTransactionGroup(
          userId,
          addTransactionGroupRequestViewModel,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TransactionGroupsApi.addTransactionGroup"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes the entire transaction group and associated transactions within it.
     * @summary Delete existing
     * @param {string} userId User id for which the transaction group belongs to.
     * @param {number} groupId The Id of the transaction group to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAnExistingTransactionGroup(
      userId: string,
      groupId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteAnExistingTransactionGroup(
          userId,
          groupId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "TransactionGroupsApi.deleteAnExistingTransactionGroup"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves a list of all individual transactions
     * @summary Get all
     * @param {string} userId User id for which the transaction group belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransactionGroups(
      userId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetTransactionGroupsViewModel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTransactionGroups(userId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TransactionGroupsApi.getTransactionGroups"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * If the transactions array is updated with an existing transaction id, that transaction will be moved from individual to a group.
     * @summary Update existing
     * @param {string} userId User id for which the transaction group belongs to.
     * @param {number} groupId The id of the transaction group which is being updated.
     * @param {UpdateTransactionGroupRequestViewModel} updateTransactionGroupRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTransactionGroup(
      userId: string,
      groupId: number,
      updateTransactionGroupRequestViewModel: UpdateTransactionGroupRequestViewModel,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateTransactionGroupResponseViewModel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateTransactionGroup(
          userId,
          groupId,
          updateTransactionGroupRequestViewModel,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TransactionGroupsApi.updateTransactionGroup"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TransactionGroupsApi - factory interface
 * @export
 */
export const TransactionGroupsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TransactionGroupsApiFp(configuration);
  return {
    /**
     * Adds a group of transactions with metadata related to all of them.
     * @summary Add new
     * @param {string} userId User Id for which to add the transaction group for.
     * @param {AddTransactionGroupRequestViewModel} addTransactionGroupRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTransactionGroup(
      userId: string,
      addTransactionGroupRequestViewModel: AddTransactionGroupRequestViewModel,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AddTransactionGroupResponseViewModel> {
      return localVarFp
        .addTransactionGroup(
          userId,
          addTransactionGroupRequestViewModel,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes the entire transaction group and associated transactions within it.
     * @summary Delete existing
     * @param {string} userId User id for which the transaction group belongs to.
     * @param {number} groupId The Id of the transaction group to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAnExistingTransactionGroup(
      userId: string,
      groupId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .deleteAnExistingTransactionGroup(userId, groupId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a list of all individual transactions
     * @summary Get all
     * @param {string} userId User id for which the transaction group belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionGroups(
      userId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetTransactionGroupsViewModel> {
      return localVarFp
        .getTransactionGroups(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * If the transactions array is updated with an existing transaction id, that transaction will be moved from individual to a group.
     * @summary Update existing
     * @param {string} userId User id for which the transaction group belongs to.
     * @param {number} groupId The id of the transaction group which is being updated.
     * @param {UpdateTransactionGroupRequestViewModel} updateTransactionGroupRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTransactionGroup(
      userId: string,
      groupId: number,
      updateTransactionGroupRequestViewModel: UpdateTransactionGroupRequestViewModel,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateTransactionGroupResponseViewModel> {
      return localVarFp
        .updateTransactionGroup(
          userId,
          groupId,
          updateTransactionGroupRequestViewModel,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TransactionGroupsApi - object-oriented interface
 * @export
 * @class TransactionGroupsApi
 * @extends {BaseAPI}
 */
export class TransactionGroupsApi extends BaseAPI {
  /**
   * Adds a group of transactions with metadata related to all of them.
   * @summary Add new
   * @param {string} userId User Id for which to add the transaction group for.
   * @param {AddTransactionGroupRequestViewModel} addTransactionGroupRequestViewModel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionGroupsApi
   */
  public addTransactionGroup(
    userId: string,
    addTransactionGroupRequestViewModel: AddTransactionGroupRequestViewModel,
    options?: RawAxiosRequestConfig
  ) {
    return TransactionGroupsApiFp(this.configuration)
      .addTransactionGroup(userId, addTransactionGroupRequestViewModel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes the entire transaction group and associated transactions within it.
   * @summary Delete existing
   * @param {string} userId User id for which the transaction group belongs to.
   * @param {number} groupId The Id of the transaction group to be deleted.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionGroupsApi
   */
  public deleteAnExistingTransactionGroup(
    userId: string,
    groupId: number,
    options?: RawAxiosRequestConfig
  ) {
    return TransactionGroupsApiFp(this.configuration)
      .deleteAnExistingTransactionGroup(userId, groupId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves a list of all individual transactions
   * @summary Get all
   * @param {string} userId User id for which the transaction group belongs to.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionGroupsApi
   */
  public getTransactionGroups(userId: string, options?: RawAxiosRequestConfig) {
    return TransactionGroupsApiFp(this.configuration)
      .getTransactionGroups(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * If the transactions array is updated with an existing transaction id, that transaction will be moved from individual to a group.
   * @summary Update existing
   * @param {string} userId User id for which the transaction group belongs to.
   * @param {number} groupId The id of the transaction group which is being updated.
   * @param {UpdateTransactionGroupRequestViewModel} updateTransactionGroupRequestViewModel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionGroupsApi
   */
  public updateTransactionGroup(
    userId: string,
    groupId: number,
    updateTransactionGroupRequestViewModel: UpdateTransactionGroupRequestViewModel,
    options?: RawAxiosRequestConfig
  ) {
    return TransactionGroupsApiFp(this.configuration)
      .updateTransactionGroup(
        userId,
        groupId,
        updateTransactionGroupRequestViewModel,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Deleted any transaction, whether its individual or from a group.
     * @summary Delete existing
     * @param {string} userId User id for which the transaction belongs to.
     * @param {string} transactionId The id of the transaction to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAnExistingTransaction: async (
      userId: string,
      transactionId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("deleteAnExistingTransaction", "userId", userId);
      // verify required parameter 'transactionId' is not null or undefined
      assertParamExists(
        "deleteAnExistingTransaction",
        "transactionId",
        transactionId
      );
      const localVarPath = `/api/users/{user_id}/transactions/:transaction_id`
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
        .replace(
          `{${"transaction_id"}}`,
          encodeURIComponent(String(transactionId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a list of all individual and grouped transactions
     * @summary Get all
     * @param {string} userId User id for which the transaction belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get: async (
      userId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("get", "userId", userId);
      const localVarPath = `/api/users/{user_id}/transactions`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This is a generic update endpoint which does not assume whether transaction is individual or group. It only updates the contents of the transaction without moving it.
     * @summary Update existing
     * @param {string} userId User id for which the transaction belongs to.
     * @param {string} transactionId The id of the specific transaction to be updated.
     * @param {UpdateTransactionRequestViewModel} updateTransactionRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAnExistingTransaction: async (
      userId: string,
      transactionId: string,
      updateTransactionRequestViewModel: UpdateTransactionRequestViewModel,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("updateAnExistingTransaction", "userId", userId);
      // verify required parameter 'transactionId' is not null or undefined
      assertParamExists(
        "updateAnExistingTransaction",
        "transactionId",
        transactionId
      );
      // verify required parameter 'updateTransactionRequestViewModel' is not null or undefined
      assertParamExists(
        "updateAnExistingTransaction",
        "updateTransactionRequestViewModel",
        updateTransactionRequestViewModel
      );
      const localVarPath = `/api/users/{user_id}/transactions/:transaction_id`
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
        .replace(
          `{${"transaction_id"}}`,
          encodeURIComponent(String(transactionId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateTransactionRequestViewModel,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TransactionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Deleted any transaction, whether its individual or from a group.
     * @summary Delete existing
     * @param {string} userId User id for which the transaction belongs to.
     * @param {string} transactionId The id of the transaction to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAnExistingTransaction(
      userId: string,
      transactionId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteAnExistingTransaction(
          userId,
          transactionId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TransactionsApi.deleteAnExistingTransaction"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves a list of all individual and grouped transactions
     * @summary Get all
     * @param {string} userId User id for which the transaction belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async get(
      userId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetTransactionsViewModel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.get(
        userId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TransactionsApi.get"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This is a generic update endpoint which does not assume whether transaction is individual or group. It only updates the contents of the transaction without moving it.
     * @summary Update existing
     * @param {string} userId User id for which the transaction belongs to.
     * @param {string} transactionId The id of the specific transaction to be updated.
     * @param {UpdateTransactionRequestViewModel} updateTransactionRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateAnExistingTransaction(
      userId: string,
      transactionId: string,
      updateTransactionRequestViewModel: UpdateTransactionRequestViewModel,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateTransactionResponseViewModel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateAnExistingTransaction(
          userId,
          transactionId,
          updateTransactionRequestViewModel,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TransactionsApi.updateAnExistingTransaction"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TransactionsApiFp(configuration);
  return {
    /**
     * Deleted any transaction, whether its individual or from a group.
     * @summary Delete existing
     * @param {string} userId User id for which the transaction belongs to.
     * @param {string} transactionId The id of the transaction to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAnExistingTransaction(
      userId: string,
      transactionId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .deleteAnExistingTransaction(userId, transactionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a list of all individual and grouped transactions
     * @summary Get all
     * @param {string} userId User id for which the transaction belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get(
      userId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetTransactionsViewModel> {
      return localVarFp
        .get(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This is a generic update endpoint which does not assume whether transaction is individual or group. It only updates the contents of the transaction without moving it.
     * @summary Update existing
     * @param {string} userId User id for which the transaction belongs to.
     * @param {string} transactionId The id of the specific transaction to be updated.
     * @param {UpdateTransactionRequestViewModel} updateTransactionRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAnExistingTransaction(
      userId: string,
      transactionId: string,
      updateTransactionRequestViewModel: UpdateTransactionRequestViewModel,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateTransactionResponseViewModel> {
      return localVarFp
        .updateAnExistingTransaction(
          userId,
          transactionId,
          updateTransactionRequestViewModel,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
  /**
   * Deleted any transaction, whether its individual or from a group.
   * @summary Delete existing
   * @param {string} userId User id for which the transaction belongs to.
   * @param {string} transactionId The id of the transaction to be deleted.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public deleteAnExistingTransaction(
    userId: string,
    transactionId: string,
    options?: RawAxiosRequestConfig
  ) {
    return TransactionsApiFp(this.configuration)
      .deleteAnExistingTransaction(userId, transactionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves a list of all individual and grouped transactions
   * @summary Get all
   * @param {string} userId User id for which the transaction belongs to.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public get(userId: string, options?: RawAxiosRequestConfig) {
    return TransactionsApiFp(this.configuration)
      .get(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This is a generic update endpoint which does not assume whether transaction is individual or group. It only updates the contents of the transaction without moving it.
   * @summary Update existing
   * @param {string} userId User id for which the transaction belongs to.
   * @param {string} transactionId The id of the specific transaction to be updated.
   * @param {UpdateTransactionRequestViewModel} updateTransactionRequestViewModel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public updateAnExistingTransaction(
    userId: string,
    transactionId: string,
    updateTransactionRequestViewModel: UpdateTransactionRequestViewModel,
    options?: RawAxiosRequestConfig
  ) {
    return TransactionsApiFp(this.configuration)
      .updateAnExistingTransaction(
        userId,
        transactionId,
        updateTransactionRequestViewModel,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserAssetsApi - axios parameter creator
 * @export
 */
export const UserAssetsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Deletes manually added user asset along with all the related information about it. Return an error if the asset is in use or other assets are dependent on it as base.
     * @summary Delete user asset
     * @param {string} userId User id for which the asset belongs to.
     * @param {number} assetId The Id of the asset to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAsset: async (
      userId: string,
      assetId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("deleteAsset", "userId", userId);
      // verify required parameter 'assetId' is not null or undefined
      assertParamExists("deleteAsset", "assetId", assetId);
      const localVarPath = `/api/users/{user_id}/assets/:asset_id`
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
        .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes user asset pair and its associated metadata.
     * @summary Delete user asset pair
     * @param {string} userId User id for which the asset belongs to.
     * @param {number} assetId The Id of the user asset.
     * @param {number} referenceId The Id of the reference asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAssetPair: async (
      userId: string,
      assetId: number,
      referenceId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("deleteAssetPair", "userId", userId);
      // verify required parameter 'assetId' is not null or undefined
      assertParamExists("deleteAssetPair", "assetId", assetId);
      // verify required parameter 'referenceId' is not null or undefined
      assertParamExists("deleteAssetPair", "referenceId", referenceId);
      const localVarPath = `/api/users/{user_id}/assets/:asset_id/:reference_id`
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
        .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)))
        .replace(
          `{${"reference_id"}}`,
          encodeURIComponent(String(referenceId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Request with no parameters deletes all rates related to a user asset and its pair. If the parameters are specified, it deletes only the subset of it.
     * @summary Delete user asset pair rates
     * @param {string} userId User id for which the asset belongs to.
     * @param {number} assetId The Id of the user asset.
     * @param {number} referenceId The Id of the reference asset.
     * @param {string} startTimestamp From which timestamp delete the rates inclusive.
     * @param {string} endTimestamp Until which timestamp delete the rates inclusive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAssetPairRates: async (
      userId: string,
      assetId: number,
      referenceId: number,
      startTimestamp: string,
      endTimestamp: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("deleteAssetPairRates", "userId", userId);
      // verify required parameter 'assetId' is not null or undefined
      assertParamExists("deleteAssetPairRates", "assetId", assetId);
      // verify required parameter 'referenceId' is not null or undefined
      assertParamExists("deleteAssetPairRates", "referenceId", referenceId);
      // verify required parameter 'startTimestamp' is not null or undefined
      assertParamExists(
        "deleteAssetPairRates",
        "startTimestamp",
        startTimestamp
      );
      // verify required parameter 'endTimestamp' is not null or undefined
      assertParamExists("deleteAssetPairRates", "endTimestamp", endTimestamp);
      const localVarPath =
        `/api/users/{user_id}/assets/:asset_id/:reference_id/rates`
          .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
          .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)))
          .replace(
            `{${"reference_id"}}`,
            encodeURIComponent(String(referenceId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (startTimestamp !== undefined) {
        localVarQueryParameter["start_timestamp"] =
          (startTimestamp as any) instanceof Date
            ? (startTimestamp as any).toISOString()
            : startTimestamp;
      }

      if (endTimestamp !== undefined) {
        localVarQueryParameter["end_timestamp"] =
          (endTimestamp as any) instanceof Date
            ? (endTimestamp as any).toISOString()
            : endTimestamp;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets an custom asset added by user
     * @summary Get user asset
     * @param {string} userId Id of the user for which asset belongs to.
     * @param {number} assetId Id of the user asset to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAsset: async (
      userId: string,
      assetId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getUserAsset", "userId", userId);
      // verify required parameter 'assetId' is not null or undefined
      assertParamExists("getUserAsset", "assetId", assetId);
      const localVarPath = `/api/users/{user_id}/assets/:asset_id`
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
        .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets metadata about user asset pair
     * @summary Get user asset pair
     * @param {string} userId Id of the user for which asset belongs to.
     * @param {number} assetId Id of the user asset to retrieve.
     * @param {number} referenceId Id of the reference asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAssetPair: async (
      userId: string,
      assetId: number,
      referenceId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getUserAssetPair", "userId", userId);
      // verify required parameter 'assetId' is not null or undefined
      assertParamExists("getUserAssetPair", "assetId", assetId);
      // verify required parameter 'referenceId' is not null or undefined
      assertParamExists("getUserAssetPair", "referenceId", referenceId);
      const localVarPath = `/api/users/{user_id}/assets/:asset_id/:reference_id`
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
        .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)))
        .replace(
          `{${"reference_id"}}`,
          encodeURIComponent(String(referenceId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets user asset pair rates based on provided query params
     * @summary Get user asset pair rates
     * @param {string} userId Id of the user for which asset belongs to.
     * @param {number} assetId Id of the user asset to retrieve.
     * @param {number} referenceId Id of the reference asset.
     * @param {string} [range] The range time for which to retrieve the rates for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAssetPairRates: async (
      userId: string,
      assetId: number,
      referenceId: number,
      range?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getUserAssetPairRates", "userId", userId);
      // verify required parameter 'assetId' is not null or undefined
      assertParamExists("getUserAssetPairRates", "assetId", assetId);
      // verify required parameter 'referenceId' is not null or undefined
      assertParamExists("getUserAssetPairRates", "referenceId", referenceId);
      const localVarPath =
        `/api/users/{user_id}/assets/:asset_id/:reference_id/rates`
          .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
          .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)))
          .replace(
            `{${"reference_id"}}`,
            encodeURIComponent(String(referenceId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (range !== undefined) {
        localVarQueryParameter["range"] = range;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds a user defined asset.
     * @summary Add user asset
     * @param {string} userId User id for which to add the asset to.
     * @param {AddAssetRequestViewModel} addAssetRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCustomAsset: async (
      userId: string,
      addAssetRequestViewModel: AddAssetRequestViewModel,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("postCustomAsset", "userId", userId);
      // verify required parameter 'addAssetRequestViewModel' is not null or undefined
      assertParamExists(
        "postCustomAsset",
        "addAssetRequestViewModel",
        addAssetRequestViewModel
      );
      const localVarPath = `/api/users/{user_id}/assets`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addAssetRequestViewModel,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds a list of user asset pair rates. The list may contain one or many elements. If the rate already exists, error will be returned.
     * @summary Add user asset pair rates
     * @param {string} userId User id for which the asset belongs to.
     * @param {number} assetId The Id of the user asset.
     * @param {number} referenceId The Id of the reference asset.
     * @param {AddAssetPairRatesRequestViewModel} addAssetPairRatesRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCustomAssetRates: async (
      userId: string,
      assetId: number,
      referenceId: number,
      addAssetPairRatesRequestViewModel: AddAssetPairRatesRequestViewModel,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("postCustomAssetRates", "userId", userId);
      // verify required parameter 'assetId' is not null or undefined
      assertParamExists("postCustomAssetRates", "assetId", assetId);
      // verify required parameter 'referenceId' is not null or undefined
      assertParamExists("postCustomAssetRates", "referenceId", referenceId);
      // verify required parameter 'addAssetPairRatesRequestViewModel' is not null or undefined
      assertParamExists(
        "postCustomAssetRates",
        "addAssetPairRatesRequestViewModel",
        addAssetPairRatesRequestViewModel
      );
      const localVarPath =
        `/api/users/{user_id}/assets/:asset_id/:reference_id/rates`
          .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
          .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)))
          .replace(
            `{${"reference_id"}}`,
            encodeURIComponent(String(referenceId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addAssetPairRatesRequestViewModel,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update already existing user defined asset.
     * @summary Update user asset
     * @param {string} userId User id for which to add the asset to.
     * @param {number} assetId User asset to update.
     * @param {UpdateAssetRequestViewModel} updateAssetRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putCustomAsset: async (
      userId: string,
      assetId: number,
      updateAssetRequestViewModel: UpdateAssetRequestViewModel,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("putCustomAsset", "userId", userId);
      // verify required parameter 'assetId' is not null or undefined
      assertParamExists("putCustomAsset", "assetId", assetId);
      // verify required parameter 'updateAssetRequestViewModel' is not null or undefined
      assertParamExists(
        "putCustomAsset",
        "updateAssetRequestViewModel",
        updateAssetRequestViewModel
      );
      const localVarPath = `/api/users/{user_id}/assets/:asset_id`
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
        .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateAssetRequestViewModel,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Change the metadata related to user asset pair. As user asset pair is not uniquely identifiable we do not need a POST to create it. It is created by default as you add rates, and this endpoint serves as a way to add or update metadata.
     * @summary Update user asset pair metadata
     * @param {string} userId User id for which to add the asset to.
     * @param {number} assetId User asset to update.
     * @param {number} referenceId User asset to update.
     * @param {UpdateAssetPairRequestViewModel} updateAssetPairRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putCustomAssetPair: async (
      userId: string,
      assetId: number,
      referenceId: number,
      updateAssetPairRequestViewModel: UpdateAssetPairRequestViewModel,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("putCustomAssetPair", "userId", userId);
      // verify required parameter 'assetId' is not null or undefined
      assertParamExists("putCustomAssetPair", "assetId", assetId);
      // verify required parameter 'referenceId' is not null or undefined
      assertParamExists("putCustomAssetPair", "referenceId", referenceId);
      // verify required parameter 'updateAssetPairRequestViewModel' is not null or undefined
      assertParamExists(
        "putCustomAssetPair",
        "updateAssetPairRequestViewModel",
        updateAssetPairRequestViewModel
      );
      const localVarPath =
        `/api/users/{user_id}/assets/:asset_id/:reference_id/usermetadata`
          .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
          .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)))
          .replace(
            `{${"reference_id"}}`,
            encodeURIComponent(String(referenceId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication auth_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateAssetPairRequestViewModel,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserAssetsApi - functional programming interface
 * @export
 */
export const UserAssetsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    UserAssetsApiAxiosParamCreator(configuration);
  return {
    /**
     * Deletes manually added user asset along with all the related information about it. Return an error if the asset is in use or other assets are dependent on it as base.
     * @summary Delete user asset
     * @param {string} userId User id for which the asset belongs to.
     * @param {number} assetId The Id of the asset to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAsset(
      userId: string,
      assetId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAsset(
        userId,
        assetId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserAssetsApi.deleteAsset"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes user asset pair and its associated metadata.
     * @summary Delete user asset pair
     * @param {string} userId User id for which the asset belongs to.
     * @param {number} assetId The Id of the user asset.
     * @param {number} referenceId The Id of the reference asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAssetPair(
      userId: string,
      assetId: number,
      referenceId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAssetPair(
        userId,
        assetId,
        referenceId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserAssetsApi.deleteAssetPair"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Request with no parameters deletes all rates related to a user asset and its pair. If the parameters are specified, it deletes only the subset of it.
     * @summary Delete user asset pair rates
     * @param {string} userId User id for which the asset belongs to.
     * @param {number} assetId The Id of the user asset.
     * @param {number} referenceId The Id of the reference asset.
     * @param {string} startTimestamp From which timestamp delete the rates inclusive.
     * @param {string} endTimestamp Until which timestamp delete the rates inclusive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAssetPairRates(
      userId: string,
      assetId: number,
      referenceId: number,
      startTimestamp: string,
      endTimestamp: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteAssetPairRates(
          userId,
          assetId,
          referenceId,
          startTimestamp,
          endTimestamp,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserAssetsApi.deleteAssetPairRates"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Gets an custom asset added by user
     * @summary Get user asset
     * @param {string} userId Id of the user for which asset belongs to.
     * @param {number} assetId Id of the user asset to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserAsset(
      userId: string,
      assetId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetAssetResponseViewModel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAsset(
        userId,
        assetId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserAssetsApi.getUserAsset"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Gets metadata about user asset pair
     * @summary Get user asset pair
     * @param {string} userId Id of the user for which asset belongs to.
     * @param {number} assetId Id of the user asset to retrieve.
     * @param {number} referenceId Id of the reference asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserAssetPair(
      userId: string,
      assetId: number,
      referenceId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetUserAssetPairResponseViewModel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserAssetPair(
          userId,
          assetId,
          referenceId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserAssetsApi.getUserAssetPair"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Gets user asset pair rates based on provided query params
     * @summary Get user asset pair rates
     * @param {string} userId Id of the user for which asset belongs to.
     * @param {number} assetId Id of the user asset to retrieve.
     * @param {number} referenceId Id of the reference asset.
     * @param {string} [range] The range time for which to retrieve the rates for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserAssetPairRates(
      userId: string,
      assetId: number,
      referenceId: number,
      range?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetAssetPairRatesResponseViewModel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserAssetPairRates(
          userId,
          assetId,
          referenceId,
          range,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserAssetsApi.getUserAssetPairRates"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds a user defined asset.
     * @summary Add user asset
     * @param {string} userId User id for which to add the asset to.
     * @param {AddAssetRequestViewModel} addAssetRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postCustomAsset(
      userId: string,
      addAssetRequestViewModel: AddAssetRequestViewModel,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AddAssetResponseViewModel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postCustomAsset(
        userId,
        addAssetRequestViewModel,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserAssetsApi.postCustomAsset"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds a list of user asset pair rates. The list may contain one or many elements. If the rate already exists, error will be returned.
     * @summary Add user asset pair rates
     * @param {string} userId User id for which the asset belongs to.
     * @param {number} assetId The Id of the user asset.
     * @param {number} referenceId The Id of the reference asset.
     * @param {AddAssetPairRatesRequestViewModel} addAssetPairRatesRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postCustomAssetRates(
      userId: string,
      assetId: number,
      referenceId: number,
      addAssetPairRatesRequestViewModel: AddAssetPairRatesRequestViewModel,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AddAssetPairRatesResponseViewModel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postCustomAssetRates(
          userId,
          assetId,
          referenceId,
          addAssetPairRatesRequestViewModel,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserAssetsApi.postCustomAssetRates"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update already existing user defined asset.
     * @summary Update user asset
     * @param {string} userId User id for which to add the asset to.
     * @param {number} assetId User asset to update.
     * @param {UpdateAssetRequestViewModel} updateAssetRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putCustomAsset(
      userId: string,
      assetId: number,
      updateAssetRequestViewModel: UpdateAssetRequestViewModel,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateAssetResponseViewModel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putCustomAsset(
        userId,
        assetId,
        updateAssetRequestViewModel,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserAssetsApi.putCustomAsset"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Change the metadata related to user asset pair. As user asset pair is not uniquely identifiable we do not need a POST to create it. It is created by default as you add rates, and this endpoint serves as a way to add or update metadata.
     * @summary Update user asset pair metadata
     * @param {string} userId User id for which to add the asset to.
     * @param {number} assetId User asset to update.
     * @param {number} referenceId User asset to update.
     * @param {UpdateAssetPairRequestViewModel} updateAssetPairRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putCustomAssetPair(
      userId: string,
      assetId: number,
      referenceId: number,
      updateAssetPairRequestViewModel: UpdateAssetPairRequestViewModel,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateAssetPairResponseViewModel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putCustomAssetPair(
          userId,
          assetId,
          referenceId,
          updateAssetPairRequestViewModel,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserAssetsApi.putCustomAssetPair"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UserAssetsApi - factory interface
 * @export
 */
export const UserAssetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserAssetsApiFp(configuration);
  return {
    /**
     * Deletes manually added user asset along with all the related information about it. Return an error if the asset is in use or other assets are dependent on it as base.
     * @summary Delete user asset
     * @param {string} userId User id for which the asset belongs to.
     * @param {number} assetId The Id of the asset to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAsset(
      userId: string,
      assetId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .deleteAsset(userId, assetId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes user asset pair and its associated metadata.
     * @summary Delete user asset pair
     * @param {string} userId User id for which the asset belongs to.
     * @param {number} assetId The Id of the user asset.
     * @param {number} referenceId The Id of the reference asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAssetPair(
      userId: string,
      assetId: number,
      referenceId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .deleteAssetPair(userId, assetId, referenceId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Request with no parameters deletes all rates related to a user asset and its pair. If the parameters are specified, it deletes only the subset of it.
     * @summary Delete user asset pair rates
     * @param {string} userId User id for which the asset belongs to.
     * @param {number} assetId The Id of the user asset.
     * @param {number} referenceId The Id of the reference asset.
     * @param {string} startTimestamp From which timestamp delete the rates inclusive.
     * @param {string} endTimestamp Until which timestamp delete the rates inclusive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAssetPairRates(
      userId: string,
      assetId: number,
      referenceId: number,
      startTimestamp: string,
      endTimestamp: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .deleteAssetPairRates(
          userId,
          assetId,
          referenceId,
          startTimestamp,
          endTimestamp,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets an custom asset added by user
     * @summary Get user asset
     * @param {string} userId Id of the user for which asset belongs to.
     * @param {number} assetId Id of the user asset to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAsset(
      userId: string,
      assetId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetAssetResponseViewModel> {
      return localVarFp
        .getUserAsset(userId, assetId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets metadata about user asset pair
     * @summary Get user asset pair
     * @param {string} userId Id of the user for which asset belongs to.
     * @param {number} assetId Id of the user asset to retrieve.
     * @param {number} referenceId Id of the reference asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAssetPair(
      userId: string,
      assetId: number,
      referenceId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetUserAssetPairResponseViewModel> {
      return localVarFp
        .getUserAssetPair(userId, assetId, referenceId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets user asset pair rates based on provided query params
     * @summary Get user asset pair rates
     * @param {string} userId Id of the user for which asset belongs to.
     * @param {number} assetId Id of the user asset to retrieve.
     * @param {number} referenceId Id of the reference asset.
     * @param {string} [range] The range time for which to retrieve the rates for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAssetPairRates(
      userId: string,
      assetId: number,
      referenceId: number,
      range?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetAssetPairRatesResponseViewModel> {
      return localVarFp
        .getUserAssetPairRates(userId, assetId, referenceId, range, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds a user defined asset.
     * @summary Add user asset
     * @param {string} userId User id for which to add the asset to.
     * @param {AddAssetRequestViewModel} addAssetRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCustomAsset(
      userId: string,
      addAssetRequestViewModel: AddAssetRequestViewModel,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AddAssetResponseViewModel> {
      return localVarFp
        .postCustomAsset(userId, addAssetRequestViewModel, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds a list of user asset pair rates. The list may contain one or many elements. If the rate already exists, error will be returned.
     * @summary Add user asset pair rates
     * @param {string} userId User id for which the asset belongs to.
     * @param {number} assetId The Id of the user asset.
     * @param {number} referenceId The Id of the reference asset.
     * @param {AddAssetPairRatesRequestViewModel} addAssetPairRatesRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCustomAssetRates(
      userId: string,
      assetId: number,
      referenceId: number,
      addAssetPairRatesRequestViewModel: AddAssetPairRatesRequestViewModel,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AddAssetPairRatesResponseViewModel> {
      return localVarFp
        .postCustomAssetRates(
          userId,
          assetId,
          referenceId,
          addAssetPairRatesRequestViewModel,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update already existing user defined asset.
     * @summary Update user asset
     * @param {string} userId User id for which to add the asset to.
     * @param {number} assetId User asset to update.
     * @param {UpdateAssetRequestViewModel} updateAssetRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putCustomAsset(
      userId: string,
      assetId: number,
      updateAssetRequestViewModel: UpdateAssetRequestViewModel,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateAssetResponseViewModel> {
      return localVarFp
        .putCustomAsset(userId, assetId, updateAssetRequestViewModel, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Change the metadata related to user asset pair. As user asset pair is not uniquely identifiable we do not need a POST to create it. It is created by default as you add rates, and this endpoint serves as a way to add or update metadata.
     * @summary Update user asset pair metadata
     * @param {string} userId User id for which to add the asset to.
     * @param {number} assetId User asset to update.
     * @param {number} referenceId User asset to update.
     * @param {UpdateAssetPairRequestViewModel} updateAssetPairRequestViewModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putCustomAssetPair(
      userId: string,
      assetId: number,
      referenceId: number,
      updateAssetPairRequestViewModel: UpdateAssetPairRequestViewModel,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateAssetPairResponseViewModel> {
      return localVarFp
        .putCustomAssetPair(
          userId,
          assetId,
          referenceId,
          updateAssetPairRequestViewModel,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserAssetsApi - object-oriented interface
 * @export
 * @class UserAssetsApi
 * @extends {BaseAPI}
 */
export class UserAssetsApi extends BaseAPI {
  /**
   * Deletes manually added user asset along with all the related information about it. Return an error if the asset is in use or other assets are dependent on it as base.
   * @summary Delete user asset
   * @param {string} userId User id for which the asset belongs to.
   * @param {number} assetId The Id of the asset to be deleted.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAssetsApi
   */
  public deleteAsset(
    userId: string,
    assetId: number,
    options?: RawAxiosRequestConfig
  ) {
    return UserAssetsApiFp(this.configuration)
      .deleteAsset(userId, assetId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes user asset pair and its associated metadata.
   * @summary Delete user asset pair
   * @param {string} userId User id for which the asset belongs to.
   * @param {number} assetId The Id of the user asset.
   * @param {number} referenceId The Id of the reference asset.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAssetsApi
   */
  public deleteAssetPair(
    userId: string,
    assetId: number,
    referenceId: number,
    options?: RawAxiosRequestConfig
  ) {
    return UserAssetsApiFp(this.configuration)
      .deleteAssetPair(userId, assetId, referenceId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Request with no parameters deletes all rates related to a user asset and its pair. If the parameters are specified, it deletes only the subset of it.
   * @summary Delete user asset pair rates
   * @param {string} userId User id for which the asset belongs to.
   * @param {number} assetId The Id of the user asset.
   * @param {number} referenceId The Id of the reference asset.
   * @param {string} startTimestamp From which timestamp delete the rates inclusive.
   * @param {string} endTimestamp Until which timestamp delete the rates inclusive.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAssetsApi
   */
  public deleteAssetPairRates(
    userId: string,
    assetId: number,
    referenceId: number,
    startTimestamp: string,
    endTimestamp: string,
    options?: RawAxiosRequestConfig
  ) {
    return UserAssetsApiFp(this.configuration)
      .deleteAssetPairRates(
        userId,
        assetId,
        referenceId,
        startTimestamp,
        endTimestamp,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets an custom asset added by user
   * @summary Get user asset
   * @param {string} userId Id of the user for which asset belongs to.
   * @param {number} assetId Id of the user asset to retrieve.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAssetsApi
   */
  public getUserAsset(
    userId: string,
    assetId: number,
    options?: RawAxiosRequestConfig
  ) {
    return UserAssetsApiFp(this.configuration)
      .getUserAsset(userId, assetId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets metadata about user asset pair
   * @summary Get user asset pair
   * @param {string} userId Id of the user for which asset belongs to.
   * @param {number} assetId Id of the user asset to retrieve.
   * @param {number} referenceId Id of the reference asset.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAssetsApi
   */
  public getUserAssetPair(
    userId: string,
    assetId: number,
    referenceId: number,
    options?: RawAxiosRequestConfig
  ) {
    return UserAssetsApiFp(this.configuration)
      .getUserAssetPair(userId, assetId, referenceId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets user asset pair rates based on provided query params
   * @summary Get user asset pair rates
   * @param {string} userId Id of the user for which asset belongs to.
   * @param {number} assetId Id of the user asset to retrieve.
   * @param {number} referenceId Id of the reference asset.
   * @param {string} [range] The range time for which to retrieve the rates for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAssetsApi
   */
  public getUserAssetPairRates(
    userId: string,
    assetId: number,
    referenceId: number,
    range?: string,
    options?: RawAxiosRequestConfig
  ) {
    return UserAssetsApiFp(this.configuration)
      .getUserAssetPairRates(userId, assetId, referenceId, range, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds a user defined asset.
   * @summary Add user asset
   * @param {string} userId User id for which to add the asset to.
   * @param {AddAssetRequestViewModel} addAssetRequestViewModel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAssetsApi
   */
  public postCustomAsset(
    userId: string,
    addAssetRequestViewModel: AddAssetRequestViewModel,
    options?: RawAxiosRequestConfig
  ) {
    return UserAssetsApiFp(this.configuration)
      .postCustomAsset(userId, addAssetRequestViewModel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds a list of user asset pair rates. The list may contain one or many elements. If the rate already exists, error will be returned.
   * @summary Add user asset pair rates
   * @param {string} userId User id for which the asset belongs to.
   * @param {number} assetId The Id of the user asset.
   * @param {number} referenceId The Id of the reference asset.
   * @param {AddAssetPairRatesRequestViewModel} addAssetPairRatesRequestViewModel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAssetsApi
   */
  public postCustomAssetRates(
    userId: string,
    assetId: number,
    referenceId: number,
    addAssetPairRatesRequestViewModel: AddAssetPairRatesRequestViewModel,
    options?: RawAxiosRequestConfig
  ) {
    return UserAssetsApiFp(this.configuration)
      .postCustomAssetRates(
        userId,
        assetId,
        referenceId,
        addAssetPairRatesRequestViewModel,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update already existing user defined asset.
   * @summary Update user asset
   * @param {string} userId User id for which to add the asset to.
   * @param {number} assetId User asset to update.
   * @param {UpdateAssetRequestViewModel} updateAssetRequestViewModel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAssetsApi
   */
  public putCustomAsset(
    userId: string,
    assetId: number,
    updateAssetRequestViewModel: UpdateAssetRequestViewModel,
    options?: RawAxiosRequestConfig
  ) {
    return UserAssetsApiFp(this.configuration)
      .putCustomAsset(userId, assetId, updateAssetRequestViewModel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Change the metadata related to user asset pair. As user asset pair is not uniquely identifiable we do not need a POST to create it. It is created by default as you add rates, and this endpoint serves as a way to add or update metadata.
   * @summary Update user asset pair metadata
   * @param {string} userId User id for which to add the asset to.
   * @param {number} assetId User asset to update.
   * @param {number} referenceId User asset to update.
   * @param {UpdateAssetPairRequestViewModel} updateAssetPairRequestViewModel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAssetsApi
   */
  public putCustomAssetPair(
    userId: string,
    assetId: number,
    referenceId: number,
    updateAssetPairRequestViewModel: UpdateAssetPairRequestViewModel,
    options?: RawAxiosRequestConfig
  ) {
    return UserAssetsApiFp(this.configuration)
      .putCustomAssetPair(
        userId,
        assetId,
        referenceId,
        updateAssetPairRequestViewModel,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
